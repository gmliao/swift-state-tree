#!/usr/bin/env node
/**
 * Generate TypeScript types and constants from a StateTree schema.json.
 *
 * Usage:
 *   pnpm/npx/yarn tsx sdk/ts-codegen/src/gen-schema.ts [path/to/schema.json] [outputDir]
 *
 * Defaults:
 *   schema: ../../Examples/HummingbirdDemo/schema.json
 *   outputDir: ../../sdk/ts/generated
 */
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-nocheck

import * as fs from "fs";
import * as path from "path";
import { fileURLToPath } from "url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

type JSONSchema = {
    $ref?: string;
    type?: string;
    properties?: Record<string, JSONSchema>;
    items?: JSONSchema;
    required?: string[];
    additionalProperties?: JSONSchema;
};

type ProtocolSchema = {
    defs: Record<string, JSONSchema>;
    lands: Record<
        string,
        {
            actions?: Record<string, { $ref: string }>;
            clientEvents?: Record<string, { $ref: string }>;
            events?: Record<string, { $ref: string }>;
            sync?: {
                snapshot?: { $ref: string };
                diff?: { $ref: string };
            };
        }
    >;
};

const HEADER = `// AUTOGENERATED BY sdk/ts-codegen/src/gen-schema.ts - DO NOT EDIT.
/* eslint-disable */`;

const schemaPath =
    process.argv[2] ??
    path.resolve(__dirname, "..", "..", "..", "Examples", "HummingbirdDemo", "schema.json");
const outDir =
    process.argv[3] ?? path.resolve(__dirname, "..", "..", "ts", "generated");
const runtimeImportPath = process.argv[4] ?? "../src/runtime/LandViewRuntime";

fs.mkdirSync(outDir, { recursive: true });

function readSchema(filePath: string): ProtocolSchema {
    const json = fs.readFileSync(filePath, "utf8");
    return JSON.parse(json) as ProtocolSchema;
}

function refToType(ref: string): string {
    if (!ref) return "unknown";
    const parts = ref.split("/");
    return parts[parts.length - 1];
}

function lowerFirst(value: string): string {
    if (!value) return value;
    return value[0].toLowerCase() + value.slice(1);
}

function pascalCase(value: string): string {
    return value
        .split(/[^a-zA-Z0-9]+/)
        .filter(Boolean)
        .map((part) => part[0].toUpperCase() + part.slice(1))
        .join("");
}

function renderType(schema: JSONSchema): string {
    if (schema.$ref) {
        return refToType(schema.$ref);
    }

    switch (schema.type) {
    case "string":
        return "string";
    case "integer":
    case "number":
        return "number";
    case "boolean":
        return "boolean";
    case "array": {
        const itemType = schema.items ? renderType(schema.items) : "unknown";
        return `Array<${itemType}>`;
    }
    case "object":
        return renderObject(schema);
    default:
        return "unknown";
    }
}

function renderObject(schema: JSONSchema): string {
    const props = schema.properties ?? {};
    const required = new Set(schema.required ?? []);
    const propEntries = Object.entries(props);

    if (propEntries.length === 0 && !schema.additionalProperties) {
        // Explicit empty payload (e.g., Ping) vs open object (e.g., JSON Patch value)
        if (schema.required && schema.required.length === 0) {
            return "Record<string, never>";
        }
        return "Record<string, unknown>";
    }

    const lines: string[] = ["{"]; // opening brace

    for (const [name, propSchema] of propEntries) {
        const optional = required.has(name) ? "" : "?";
        const rendered = renderType(propSchema);
        const indented =
            rendered.includes("\n")
                ? rendered
                      .split("\n")
                      .map((line, idx) => (idx === 0 ? line : `    ${line}`))
                      .join("\n")
                : rendered;
        lines.push(`    ${name}${optional}: ${indented};`);
    }

    if (schema.additionalProperties) {
        lines.push(`    [key: string]: ${renderType(schema.additionalProperties)};`);
    }

    lines.push("}");
    return lines.join("\n");
}

function renderDefinitions(defs: Record<string, JSONSchema>): string {
    const parts: string[] = [HEADER];
    const names = Object.keys(defs).sort();
    for (const name of names) {
        const typeBody = renderType(defs[name]);
        parts.push(`\nexport type ${name} = ${typeBody};`);
    }
    parts.push("");
    return parts.join("\n");
}

function renderUnion(name: string, values: string[]): string {
    const arr = values.map((v) => `"${v}"`).join(", ");
    return `export const ${name} = [${arr}] as const;\nexport type ${name.slice(0, -1)} = typeof ${name}[number];`;
}

function renderMaps(options: {
    mapName: string;
    landToIds: Record<string, string[]>;
    refLookup: (land: string, id: string) => string | undefined;
}): string {
    const lines: string[] = [];
    lines.push(`export interface ${options.mapName} {`);
    for (const [land, ids] of Object.entries(options.landToIds)) {
        if (ids.length === 0) continue;
        lines.push(`    "${land}": {`);
        for (const id of ids) {
            const ref = options.refLookup(land, id) ?? "unknown";
            lines.push(`        "${id}": ${ref};`);
        }
        lines.push("    };");
    }
    lines.push("}");
    return lines.join("\n");
}

function generateLandConstants(schema: ProtocolSchema): string {
    const parts: string[] = [];
    const usedTypes = new Set<string>();

    const landIds = Object.keys(schema.lands);
    parts.push(renderUnion("LAND_IDS", landIds));

    const actionIds = new Set<string>();
    const clientEventIds = new Set<string>();
    const serverEventIds = new Set<string>();
    const landActions: Record<string, string[]> = {};
    const landClientEvents: Record<string, string[]> = {};
    const landServerEvents: Record<string, string[]> = {};

    for (const [landId, land] of Object.entries(schema.lands)) {
        const actions = Object.keys(land.actions ?? {});
        const clientEvents = Object.keys(land.clientEvents ?? {});
        const events = Object.keys(land.events ?? {});

        landActions[landId] = actions;
        landClientEvents[landId] = clientEvents;
        landServerEvents[landId] = events;

        actions.forEach((id) => actionIds.add(id));
        clientEvents.forEach((id) => clientEventIds.add(id));
        events.forEach((id) => serverEventIds.add(id));
    }

    parts.push("");
    parts.push(renderUnion("ACTION_IDS", Array.from(actionIds).sort()));
    parts.push("");
    parts.push(
        renderMaps({
            mapName: "ActionPayloadsByLand",
            landToIds: landActions,
            refLookup: (land, id) => {
                const ref = schema.lands[land]?.actions?.[id]?.$ref;
                if (ref) usedTypes.add(refToType(ref));
                return ref ? refToType(ref) : undefined;
            },
        })
    );

    parts.push("");
    parts.push(renderUnion("CLIENT_EVENT_IDS", Array.from(clientEventIds).sort()));
    parts.push("");
    parts.push(
        renderMaps({
            mapName: "ClientEventPayloadsByLand",
            landToIds: landClientEvents,
            refLookup: (land, id) => {
                const ref = schema.lands[land]?.clientEvents?.[id]?.$ref;
                if (ref) usedTypes.add(refToType(ref));
                return ref ? refToType(ref) : undefined;
            },
        })
    );

    parts.push("");
    parts.push(renderUnion("SERVER_EVENT_IDS", Array.from(serverEventIds).sort()));
    parts.push("");
    parts.push(
        renderMaps({
            mapName: "ServerEventPayloadsByLand",
            landToIds: landServerEvents,
            refLookup: (land, id) => {
                const ref = schema.lands[land]?.events?.[id]?.$ref;
                if (ref) usedTypes.add(refToType(ref));
                return ref ? refToType(ref) : undefined;
            },
        })
    );

    // Snapshot/diff types per land
    parts.push("");
    parts.push("export interface SyncSchemasByLand {");
    for (const [landId, land] of Object.entries(schema.lands)) {
        const snapshotRef = land.sync?.snapshot?.$ref;
        const diffRef = land.sync?.diff?.$ref;
        const snapshot = snapshotRef ? refToType(snapshotRef) : "unknown";
        const diff = diffRef ? refToType(diffRef) : "unknown";
        if (snapshotRef) usedTypes.add(snapshot);
        if (diffRef) usedTypes.add(diff);
        parts.push(`    "${landId}": { snapshot: ${snapshot}; diff: ${diff}; };`);
    }
    parts.push("}");

    parts.push("");
    parts.push("// Helper typed accessors");
    parts.push(
        "export type ActionPayload<L extends keyof ActionPayloadsByLand, ID extends keyof ActionPayloadsByLand[L]> = ActionPayloadsByLand[L][ID];"
    );
    parts.push(
        "export type ClientEventPayload<L extends keyof ClientEventPayloadsByLand, ID extends keyof ClientEventPayloadsByLand[L]> = ClientEventPayloadsByLand[L][ID];"
    );
    parts.push(
        "export type ServerEventPayload<L extends keyof ServerEventPayloadsByLand, ID extends keyof ServerEventPayloadsByLand[L]> = ServerEventPayloadsByLand[L][ID];"
    );

    parts.push("");
    parts.push("// Normalized IDs (lowerCamelCase) for convenience");
    parts.push(
        "export const NORMALIZED_ACTION_IDS = ACTION_IDS.map((id) => id && typeof id === \"string\" ? id[0].toLowerCase() + id.slice(1) : id);"
    );
    parts.push(
        "export const NORMALIZED_CLIENT_EVENT_IDS = CLIENT_EVENT_IDS.map((id) => id && typeof id === \"string\" ? id[0].toLowerCase() + id.slice(1) : id);"
    );
    parts.push(
        "export const NORMALIZED_SERVER_EVENT_IDS = SERVER_EVENT_IDS.map((id) => id && typeof id === \"string\" ? id[0].toLowerCase() + id.slice(1) : id);"
    );

    parts.push("");
    const body = parts.join("\n");
    const typeImports = Array.from(usedTypes).sort();
    const importLine =
        typeImports.length > 0
            ? `import { ${typeImports.join(", ")} } from "./schema-types";\n`
            : "";
    return `${HEADER}\n${importLine}${body}`;
}

function generateLandClients(schema: ProtocolSchema): string {
    const parts: string[] = [HEADER];

    for (const [landId, land] of Object.entries(schema.lands)) {
        const className = `${pascalCase(landId)}LandView`;

        const snapshotRef = land.sync?.snapshot?.$ref;
        const diffRef = land.sync?.diff?.$ref;
        const snapshotType = snapshotRef ? refToType(snapshotRef) : "unknown";
        const diffType = diffRef ? refToType(diffRef) : "unknown";

        const actionEntries = Object.entries(land.actions ?? {});
        const clientEventEntries = Object.entries(land.clientEvents ?? {});
        const serverEventEntries = Object.entries(land.events ?? {});

        const collectImports = new Set<string>();
        if (snapshotRef) collectImports.add(snapshotType);
        if (diffRef) collectImports.add(diffType);
        for (const [, schemaRef] of actionEntries) {
            if (schemaRef.$ref) collectImports.add(refToType(schemaRef.$ref));
        }
        for (const [, schemaRef] of clientEventEntries) {
            if (schemaRef.$ref) collectImports.add(refToType(schemaRef.$ref));
        }
        for (const [, schemaRef] of serverEventEntries) {
            if (schemaRef.$ref) collectImports.add(refToType(schemaRef.$ref));
        }

        const imports = Array.from(collectImports).sort();

        const importLine =
            imports.length > 0 ? `import { ${imports.join(", ")} } from "./schema-types";` : "";

        parts.push(`
${importLine}
import { LandViewRuntime, JoinOptions } from "${runtimeImportPath}";
import { LAND_ID } from "./land-constants";

type ${className}Actions = {
${actionEntries
        .map(([id]) => `    ${lowerFirst(id)}: ${refToType(land.actions?.[id]?.$ref ?? "")};`)
        .join("\n")}
};

type ${className}ClientEvents = {
${clientEventEntries
        .map(([id]) => `    ${lowerFirst(id)}: ${refToType(land.clientEvents?.[id]?.$ref ?? "")};`)
        .join("\n")}
};

type ${className}ServerEvents = {
${serverEventEntries
        .map(([id]) => `    ${lowerFirst(id)}: ${refToType(land.events?.[id]?.$ref ?? "")};`)
        .join("\n")}
};

const ${lowerFirst(className)}WireIds = {
    actions: {
${actionEntries.map(([id]) => `        ${lowerFirst(id)}: "${id}",`).join("\n")}
    },
    clientEvents: {
${clientEventEntries.map(([id]) => `        ${lowerFirst(id)}: "${id}",`).join("\n")}
    },
    serverEvents: {
${serverEventEntries.map(([id]) => `        ${lowerFirst(id)}: "${id}",`).join("\n")}
    },
} as const;

export class ${className} {
    private readonly base: LandViewRuntime<
        LAND_ID,
        keyof ${className}Actions & string,
        keyof ${className}ClientEvents & string,
        keyof ${className}ServerEvents & string,
        ${snapshotType},
        ${diffType},
        ${className}Actions,
        ${className}ClientEvents,
        ${className}ServerEvents
    >;

    constructor(
        ws: WebSocket,
        landId: LAND_ID = "${landId}",
        logger?: (msg: string, meta?: unknown) => void
    ) {
        this.base = new LandViewRuntime({
            landId,
            ws,
            wireIds: ${lowerFirst(className)}WireIds,
            logger,
        });
    }

    dispose() {
        this.base.dispose();
    }

    readonly join = (options?: JoinOptions) => this.base.join(options);
    readonly leave = () => this.base.leave();

    readonly actions = {
${actionEntries
        .map(
            ([id]) =>
                `        ${lowerFirst(id)}: (payload: ${refToType(
                    land.actions?.[id]?.$ref ?? ""
                )}) => this.base.sendAction("${lowerFirst(id)}", payload),`
        )
        .join("\n")}
    };

    readonly clientEvents = {
${clientEventEntries
        .map(
            ([id]) =>
                `        ${lowerFirst(id)}: (payload: ${refToType(
                    land.clientEvents?.[id]?.$ref ?? ""
                )}) => this.base.sendClientEvent("${lowerFirst(id)}", payload),`
        )
        .join("\n")}
    };

    readonly serverEvents = {
${serverEventEntries
        .map(
            ([id]) =>
                `        on${pascalCase(id)}: (handler: (payload: ${refToType(
                    land.events?.[id]?.$ref ?? ""
                )}) => void) => this.base.onServerEvent("${lowerFirst(id)}", handler),`
        )
        .join("\n")}
    };

    readonly state = {
        onSnapshot: (handler: (s: ${snapshotType}) => void) => this.base.onSnapshot(handler),
        onDiff: (handler: (d: ${diffType}) => void) => this.base.onDiff(handler),
        getLatest: (): ${snapshotType} | null => this.base.latestSnapshot,
    };
}
`);
    }

    return parts.join("\n");
}

function writeFile(filePath: string, content: string) {
    fs.mkdirSync(path.dirname(filePath), { recursive: true });
    fs.writeFileSync(filePath, content, "utf8");
}

function main() {
    const schema = readSchema(schemaPath);
    const defsTs = renderDefinitions(schema.defs);
    const constantsTs = generateLandConstants(schema);
    const landViewsTs = generateLandClients(schema);

    writeFile(path.join(outDir, "schema-types.ts"), defsTs);
    writeFile(path.join(outDir, "land-constants.ts"), constantsTs);
    writeFile(path.join(outDir, "land-views.ts"), landViewsTs);

    const index = `${HEADER}
export * from "./schema-types";
export * from "./land-constants";
export * from "./land-views";
`;
    writeFile(path.join(outDir, "index.ts"), index);

    // eslint-disable-next-line no-console
    console.log(`Generated TypeScript files in ${outDir}`);
}

main();
