import { join } from 'node:path'
import type { LandDefinition, ProtocolSchema, SchemaDef, SchemaProperty } from './schema.js'
import { resolveRefName, mapSchemaDefToTsType, type TypeMapperContext } from './typeMapper.js'
import { writeFileRecursive } from './writeFile.js'
import type { Framework, TestFramework } from './index.js'

interface ActionBinding {
  id: string
  payloadType: string
  propertyName: string
  responseType?: string
}

interface EventBinding {
  id: string
  payloadType: string
  propertyName: string
}

interface MapPropertyBinding {
  /** Property name in state (e.g., "players") */
  propertyName: string
  /** Value type name (e.g., "PlayerState") */
  valueType: string
  /** Path in state (e.g., "/players") */
  path: string
}

function generateHeader(): string {
  return [
    '// AUTO-GENERATED BY @swiftstatetree/sdk codegen.',
    '// Do not edit this file directly.',
    ''
  ].join('\n')
}

export async function generateStateTreeFiles(
  schema: ProtocolSchema,
  outputDir: string,
  framework?: Framework,
  testFramework?: TestFramework
): Promise<void> {
  for (const [landID, landDef] of Object.entries(schema.lands)) {
    await generateForLand(schema, landID, landDef, outputDir, framework, testFramework)
  }
}

async function generateForLand(
  schema: ProtocolSchema,
  landID: string,
  landDef: LandDefinition,
  outputDir: string,
  framework?: Framework,
  testFramework?: TestFramework
): Promise<void> {
  const landDir = join(outputDir, landID)
  const classBaseName = toPascalCase(landID)
  const className = `${classBaseName}StateTree`

  const actions = collectActionBindings(schema, landDef)
  const clientEvents = collectEventBindings(landDef.clientEvents)
  const serverEvents = collectEventBindings(landDef.events)
  const mapProperties = collectMapProperties(schema, landDef.stateType)

  const bindingsSource = generateBindingsTs(schema, landID, landDef, actions, clientEvents, serverEvents)
  const indexSource = generateIndexTs(landID, className, actions, clientEvents, serverEvents, mapProperties, landDef.stateType)

  await writeFileRecursive(join(landDir, 'bindings.ts'), bindingsSource)
  await writeFileRecursive(join(landDir, 'index.ts'), indexSource)

  // Generate framework-specific helper if requested
  let composableName: string | undefined
  if (framework === 'vue') {
    composableName = `use${classBaseName}`
    const composableSource = generateVueComposable(
      landID,
      className,
      composableName,
      classBaseName,
      actions,
      clientEvents,
      landDef.stateType,
      schema
    )
    await writeFileRecursive(join(landDir, `${composableName}.ts`), composableSource)
  }

  // Generate test helpers (always generate basic mocks, optionally generate framework-specific helpers)
  const testHelpersSource = generateTestHelpers(
    schema,
    landID,
    landDef,
    classBaseName,
    composableName,
    actions,
    clientEvents,
    landDef.stateType,
    testFramework
  )
  if (testHelpersSource) {
    await writeFileRecursive(join(landDir, 'testHelpers.ts'), testHelpersSource)
  }
}

function collectActionBindings(schema: ProtocolSchema, landDef: LandDefinition): ActionBinding[] {
  const result: ActionBinding[] = []
  const actions = landDef.actions ?? {}
  const defNames = new Set(Object.keys(schema.defs))

  for (const [id, ref] of Object.entries(actions)) {
    const payloadType = resolveRefName(ref.$ref)
    const propertyName = toActionPropertyName(payloadType, id)
    const responseType = inferResponseType(payloadType, defNames)
    result.push({ id, payloadType, propertyName, responseType })
  }

  return result
}

function collectEventBindings(events?: Record<string, { $ref: string }>): EventBinding[] {
  const result: EventBinding[] = []
  if (!events) return result

  for (const [id, ref] of Object.entries(events)) {
    const payloadType = resolveRefName(ref.$ref)
    const propertyName = toEventPropertyName(payloadType, id)
    // Use the schema key (e.g., "ClickCookie") as the event ID to match
    // the event name generated by Server (which removes "Event" suffix).
    // This ensures consistency between Server event names and Client subscriptions.
    result.push({ id, payloadType, propertyName })
  }

  return result
}

/**
 * Collect Map properties from state type definition.
 * A Map property is identified by:
 * - type: "object" with additionalProperties containing a $ref
 * - or x-stateTree.nodeKind: "map"
 */
function collectMapProperties(schema: ProtocolSchema, stateType: string): MapPropertyBinding[] {
  const result: MapPropertyBinding[] = []
  const stateDef = schema.defs[stateType]
  
  if (!stateDef || !stateDef.properties) {
    return result
  }

  for (const [propName, propSchema] of Object.entries(stateDef.properties)) {
    // Check if it's a Map type
    const additionalProps = propSchema.additionalProperties
    const isMap = propSchema.type === 'object' && 
      additionalProps && 
      typeof additionalProps === 'object' &&
      '$ref' in additionalProps &&
      additionalProps.$ref

    if (isMap) {
      const valueType = resolveRefName((additionalProps as { $ref: string }).$ref)
      result.push({
        propertyName: propName,
        valueType,
        path: `/${propName}`
      })
    }
  }

  return result
}

function generateBindingsTs(
  schema: ProtocolSchema,
  landID: string,
  landDef: LandDefinition,
  actions: ActionBinding[],
  clientEvents: EventBinding[],
  serverEvents: EventBinding[]
): string {
  const lines: string[] = []
  lines.push(generateHeader())

  const importTypes = new Set<string>()
  importTypes.add(landDef.stateType)
  for (const a of actions) {
    importTypes.add(a.payloadType)
    if (a.responseType) {
      importTypes.add(a.responseType)
    }
  }
  for (const e of clientEvents) {
    importTypes.add(e.payloadType)
  }
  for (const e of serverEvents) {
    importTypes.add(e.payloadType)
  }

  const sortedImportTypes = [...importTypes].sort()
  if (sortedImportTypes.length > 0) {
    lines.push(`import type { ${sortedImportTypes.join(', ')} } from '../defs'`)
    lines.push('')
  }

  lines.push(`export const LAND_TYPE = ${JSON.stringify(landID)} as const`)
  lines.push('')

  lines.push(`export type LandState = ${landDef.stateType}`)
  lines.push('')

  // Actions
  lines.push('export interface ActionPayloads {')
  for (const a of actions) {
    lines.push(`  ${a.propertyName}: ${a.payloadType}`)
  }
  lines.push('}')
  lines.push('')

  lines.push('export interface ActionResponses {')
  for (const a of actions) {
    const responseType = a.responseType ?? 'any'
    lines.push(`  ${a.propertyName}: ${responseType}`)
  }
  lines.push('}')
  lines.push('')

  lines.push('export type ActionName = keyof ActionPayloads')
  lines.push('')

  // Client events
  lines.push('export interface ClientEventPayloads {')
  for (const e of clientEvents) {
    lines.push(`  ${e.propertyName}: ${e.payloadType}`)
  }
  lines.push('}')
  lines.push('')

  lines.push('export type ClientEventName = keyof ClientEventPayloads')
  lines.push('')

  // Server events
  lines.push('export interface ServerEventPayloads {')
  for (const e of serverEvents) {
    lines.push(`  ${e.propertyName}: ${e.payloadType}`)
  }
  lines.push('}')
  lines.push('')

  lines.push('export type ServerEventName = keyof ServerEventPayloads')
  lines.push('')

  // Event handler type aliases for better code readability
  lines.push('/** Unsubscribe function type for cleaning up event subscriptions */')
  lines.push('export type Unsubscribe = () => void')
  lines.push('')
  lines.push('/** Event handler callback type for server events */')
  lines.push('export type EventHandler<T> = (payload: T) => void')
  lines.push('')
  lines.push('/** Event subscription type for server events */')
  lines.push('export type EventSubscription<T> = {')
  lines.push('  subscribe: (handler: EventHandler<T>) => Unsubscribe')
  lines.push('}')
  lines.push('')

  lines.push('export type Actions = {')
  lines.push('  [K in ActionName]: (payload: ActionPayloads[K]) => Promise<ActionResponses[K]>')
  lines.push('}')
  lines.push('')

  lines.push('export type ClientEvents = {')
  lines.push('  [K in ClientEventName]: (payload: ClientEventPayloads[K]) => void')
  lines.push('}')
  lines.push('')

  lines.push('export type ServerEventSubscriptions = {')
  lines.push('  [K in ServerEventName]: (handler: EventHandler<ServerEventPayloads[K]>) => Unsubscribe')
  lines.push('}')
  lines.push('')

  return lines.join('\n')
}

function generateIndexTs(
  landID: string,
  className: string,
  actions: ActionBinding[],
  clientEvents: EventBinding[],
  serverEvents: EventBinding[],
  mapProperties: MapPropertyBinding[],
  stateType: string
): string {
  const lines: string[] = []
  lines.push(generateHeader())

  // Only import MapSubscriptions if there are map properties
  if (mapProperties.length > 0) {
    lines.push(`import type { StateTreeRuntime, Logger, StatePatch, MapSubscriptions } from '@swiftstatetree/sdk/core'`)
  } else {
    lines.push(`import type { StateTreeRuntime, Logger, StatePatch } from '@swiftstatetree/sdk/core'`)
  }
  lines.push(`import { StateTreeView } from '@swiftstatetree/sdk/core'`)
  lines.push(
    `import type { LandState, Actions, ClientEvents, ServerEventSubscriptions, EventSubscription, EventHandler } from './bindings'`
  )
  lines.push(`import { LAND_TYPE } from './bindings'`)
  // Import SCHEMA for type checking if available
  lines.push(`import { SCHEMA } from '../schema.js'`)
  
  // Import value types for Map properties
  if (mapProperties.length > 0) {
    const valueTypes = [...new Set(mapProperties.map(m => m.valueType))]
    lines.push(`import type { ${valueTypes.join(', ')} } from '../defs'`)
  }
  // Import action payload and response types
  const actionTypes = new Set<string>()
  for (const a of actions) {
    actionTypes.add(a.payloadType)
    if (a.responseType) {
      actionTypes.add(a.responseType)
    }
  }
  // Import client event payload types
  for (const e of clientEvents) {
    actionTypes.add(e.payloadType)
  }
  // Import server event payload types
  for (const e of serverEvents) {
    actionTypes.add(e.payloadType)
  }
  if (actionTypes.size > 0) {
    const sortedTypes = [...actionTypes].sort()
    lines.push(`import type { ${sortedTypes.join(', ')} } from '../defs'`)
  }
  lines.push('')

  // Re-export MapSubscriptions interface from SDK core (only if used)
  if (mapProperties.length > 0) {
    lines.push('// Re-export MapSubscriptions interface from SDK core')
    lines.push(`export type { MapSubscriptions } from '@swiftstatetree/sdk/core'`)
    lines.push('')
  }

  lines.push('export interface StateTreeOptions {')
  lines.push('  landID?: string')
  lines.push('  playerID?: string')
  lines.push('  deviceID?: string')
  lines.push('  metadata?: Record<string, any>')
  lines.push('  logger?: Logger')
  lines.push('}')
  lines.push('')

  lines.push(`export class ${className} {`)
  lines.push('  readonly landType = LAND_TYPE')
  lines.push('  readonly state: LandState')
  lines.push('  readonly actions: Actions')
  lines.push('  readonly events: ClientEvents')
  lines.push('  readonly on: ServerEventSubscriptions')
  lines.push('')
  
  // Map subscription properties
  for (const mapProp of mapProperties) {
    lines.push(`  /** Type-safe subscriptions for ${mapProp.propertyName} map */`)
    lines.push(`  readonly ${mapProp.propertyName}: MapSubscriptions<${mapProp.valueType}>`)
  }
  if (mapProperties.length > 0) {
    lines.push('')
  }
  
  // Type-safe action methods
  for (const a of actions) {
    const responseType = a.responseType ?? 'any'
    lines.push(`  /** Type-safe method for ${a.propertyName} action */`)
    lines.push(`  readonly ${a.propertyName}: (payload: ${a.payloadType}) => Promise<${responseType}>`)
  }
  if (actions.length > 0) {
    lines.push('')
  }
  
  // Type-safe client event methods
  for (const e of clientEvents) {
    lines.push(`  /** Type-safe method for ${e.propertyName} client event */`)
    lines.push(`  readonly ${e.propertyName}: (payload: ${e.payloadType}) => void`)
  }
  if (clientEvents.length > 0) {
    lines.push('')
  }
  
  // Type-safe server event subscriptions
  for (const e of serverEvents) {
    lines.push(`  /** Type-safe subscription for ${e.propertyName} server event */`)
    lines.push(`  readonly ${e.propertyName}: EventSubscription<${e.payloadType}>`)
  }
  if (serverEvents.length > 0) {
    lines.push('')
  }
  
  lines.push('  private readonly runtime: StateTreeRuntime')
  lines.push('  private readonly view: StateTreeView')
  lines.push('')

  lines.push('  constructor(runtime: StateTreeRuntime, options?: StateTreeOptions) {')
  lines.push('    this.runtime = runtime')
  lines.push('    const landID = options?.landID ?? LAND_TYPE')
  lines.push('    this.state = {} as LandState')
  lines.push('')
    lines.push('    this.view = runtime.createView(landID, {')
    lines.push('      schema: SCHEMA,  // Pass schema for accurate type checking')
    lines.push('      playerID: options?.playerID,')
    lines.push('      deviceID: options?.deviceID,')
    lines.push('      metadata: options?.metadata,')
    lines.push('      logger: options?.logger,')
      lines.push('      onStateUpdate: (nextState) => {')
      lines.push('        syncInto(this.state as any, nextState)')
      lines.push('      },')
  lines.push('      onError: (error, context) => {')
  lines.push('        options?.logger?.error(`StateTree view error: ${error.message}`, context)')
  lines.push('      }')
    lines.push('    })')
    lines.push('')

    // Initialize type-safe action methods
    for (const a of actions) {
      const responseType = a.responseType ?? 'any'
      lines.push(`    this.${a.propertyName} = (payload: ${a.payloadType}) => {`)
      lines.push(`      return this.view.sendAction(${JSON.stringify(a.id)}, payload) as Promise<${responseType}>`)
      lines.push(`    }`)
    }
    if (actions.length > 0) {
      lines.push('')
    }
    
    // Keep legacy actions object for backward compatibility
    lines.push('    this.actions = {')
    for (const a of actions) {
      lines.push(`      ${a.propertyName}: this.${a.propertyName},`)
    }
    lines.push('    } as Actions')
    lines.push('')

    // Initialize type-safe client event methods
    for (const e of clientEvents) {
      lines.push(`    this.${e.propertyName} = (payload: ${e.payloadType}) => {`)
      lines.push(`      this.view.sendEvent(${JSON.stringify(e.id)}, payload)`)
      lines.push(`    }`)
    }
    if (clientEvents.length > 0) {
      lines.push('')
    }
    
    // Keep legacy events object for backward compatibility
    lines.push('    this.events = {')
    for (const e of clientEvents) {
      lines.push(`      ${e.propertyName}: this.${e.propertyName},`)
    }
    lines.push('    } as ClientEvents')
    lines.push('')

  // server events
  lines.push('    this.on = {')
  for (const e of serverEvents) {
    lines.push(
      `      ${e.propertyName}: (handler) => this.view.onServerEvent(${JSON.stringify(
        e.id
      )}, handler),`
    )
  }
  lines.push('    } as ServerEventSubscriptions')
  lines.push('')
  
  // Initialize type-safe server event subscriptions
  for (const e of serverEvents) {
    lines.push(`    // Initialize ${e.propertyName} server event subscription`)
    lines.push(`    this.${e.propertyName} = {`)
    lines.push(`      subscribe: (handler: EventHandler<${e.payloadType}>) => {`)
    lines.push(`        return this.view.onServerEvent(${JSON.stringify(e.id)}, handler)`)
    lines.push(`      }`)
    lines.push(`    } as EventSubscription<${e.payloadType}>`)
  }
  if (serverEvents.length > 0) {
    lines.push('')
  }
  
  // Initialize Map subscriptions using SDK core implementation
  for (const mapProp of mapProperties) {
    lines.push(`    // Initialize ${mapProp.propertyName} map subscriptions using SDK core`)
    lines.push(`    this.${mapProp.propertyName} = this.view.createMapSubscriptions<${mapProp.valueType}>(`)
    lines.push(`      '${mapProp.path}',`)
    lines.push(`      (state) => state?.${mapProp.propertyName} as Record<string, ${mapProp.valueType}> | undefined`)
    lines.push(`    )`)
  }
  
  lines.push('  }')
  lines.push('')

  lines.push('  async join() {')
  lines.push('    return this.view.join()')
  lines.push('  }')
  lines.push('')

  lines.push('  destroy() {')
  lines.push('    this.view.destroy()')
  lines.push('  }')
  lines.push('')

  lines.push('  get landId(): string {')
  lines.push('    return this.view.landId')
  lines.push('  }')
  lines.push('')
  lines.push('  /**')
  lines.push('   * Get the current player ID (set after successful join)')
  lines.push('   */')
  lines.push('  get currentPlayerID(): string | undefined {')
  lines.push('    return this.view.currentPlayerID')
  lines.push('  }')
  lines.push('')
  lines.push('  /**')
  lines.push('   * Expose underlying runtime for advanced scenarios.')
  lines.push('   * This also ensures TypeScript treats the runtime field as used.')
  lines.push('   */')
  lines.push('  getRuntime(): StateTreeRuntime {')
  lines.push('    return this.runtime')
  lines.push('  }')
  lines.push('')
  lines.push('  /**')
  lines.push('   * Subscribe to patch operations.')
  lines.push('   * Useful for tracking add/remove/replace operations on specific paths.')
  lines.push('   * @param callback - Called for each patch with the patch info and decoded value')
  lines.push('   * @returns Unsubscribe function')
  lines.push('   */')
  lines.push('  onPatch(callback: (patch: StatePatch, decodedValue?: any) => void): () => void {')
  lines.push('    return this.view.onPatch(callback)')
  lines.push('  }')
  lines.push('}')
  lines.push('')

  lines.push('function isPlainObject(value: any): value is Record<string, any> {')
  lines.push('  if (!value || typeof value !== "object") {')
  lines.push('    return false')
  lines.push('  }')
  lines.push('  const proto = Object.getPrototypeOf(value)')
  lines.push('  return proto === Object.prototype || proto === null')
  lines.push('}')
  lines.push('')

  // Simple deep sync helper to keep `state` object identity stable.
  lines.push('function syncInto(target: any, source: any): void {')
  lines.push('  if (source == null || typeof source !== "object") {')
  lines.push('    return')
  lines.push('  }')
  lines.push('')
  lines.push('  for (const key of Object.keys(target)) {')
  lines.push('    if (!(key in source)) {')
  lines.push('      delete target[key]')
  lines.push('    }')
  lines.push('  }')
  lines.push('')
  lines.push('  for (const [key, value] of Object.entries(source)) {')
  lines.push('    const src: any = value')
  lines.push('    const dst: any = target[key]')
  lines.push('')
  lines.push('    if (Array.isArray(src)) {')
  lines.push('      if (!Array.isArray(dst)) {')
  lines.push('        target[key] = src.slice()')
  lines.push('      } else {')
  lines.push('        dst.length = 0')
  lines.push('        for (const item of src) {')
  lines.push('          dst.push(item)')
  lines.push('        }')
  lines.push('      }')
  lines.push('      continue')
  lines.push('    }')
  lines.push('')
  lines.push('    if (src && typeof src === "object") {')
  lines.push('      if (!isPlainObject(src)) {')
  lines.push('        target[key] = src')
  lines.push('        continue')
  lines.push('      }')
  lines.push('      if (!dst || typeof dst !== "object" || Array.isArray(dst) || !isPlainObject(dst)) {')
  lines.push('        target[key] = {}')
  lines.push('      }')
  lines.push('      syncInto(target[key], src)')
  lines.push('      continue')
  lines.push('    }')
  lines.push('')
  lines.push('    target[key] = src')
  lines.push('  }')
  lines.push('}')
  lines.push('')

  return lines.join('\n')
}

function toPascalCase(input: string): string {
  const parts = input.split(/[^a-zA-Z0-9]+/).filter(Boolean)
  if (parts.length === 0) return ''
  return parts
    .map((part) => part.charAt(0).toUpperCase() + part.slice(1))
    .join('')
}

function toActionPropertyName(payloadType: string, fallbackID: string): string {
  if (payloadType.endsWith('Action')) {
    const base = payloadType.slice(0, -'Action'.length)
    return lowerFirst(base)
  }
  return toCamelFromId(fallbackID)
}

function toEventPropertyName(payloadType: string, fallbackID: string): string {
  if (payloadType.endsWith('Event')) {
    const base = payloadType.slice(0, -'Event'.length)
    return lowerFirst(base)
  }
  return toCamelFromId(fallbackID)
}

function lowerFirst(value: string): string {
  if (!value) return value
  return value.charAt(0).toLowerCase() + value.slice(1)
}

function toCamelFromId(id: string): string {
  const parts = id.split(/[^a-zA-Z0-9]+/).filter(Boolean)
  if (parts.length === 0) return id
  const [first, ...rest] = parts
  return first.toLowerCase() + rest.map((p) => p.charAt(0).toUpperCase() + p.slice(1)).join('')
}

function generateVueComposable(
  landID: string,
  className: string,
  composableName: string,
  classBaseName: string,
  actions: ActionBinding[],
  clientEvents: EventBinding[],
  stateType: string,
  schema: ProtocolSchema
): string {
  const lines: string[] = []
  lines.push(generateHeader())

  lines.push("import { ref, reactive, computed } from 'vue'")
  lines.push("import type { Ref, ComputedRef } from 'vue'")
  lines.push("import { StateTreeRuntime } from '@swiftstatetree/sdk/core'")
  lines.push(`import { ${className} } from './index.js'`)
  lines.push(`import { LAND_TYPE } from './bindings.js'`)
  lines.push(`import type { ${stateType} } from '../defs.js'`)
  
  // Check if state uses DeterministicMath types (recursively)
  const stateDef = schema.defs[stateType]
  const checkedTypes = new Set<string>() // Prevent infinite recursion
  
  const checkForDeterministicMath = (propSchema: SchemaProperty): boolean => {
    // Check direct $ref
    if (propSchema.$ref) {
      const refName = resolveRefName(propSchema.$ref)
      if (isDeterministicMathType(refName)) {
        return true
      }
      // Recursively check nested type definitions
      if (!checkedTypes.has(refName)) {
        checkedTypes.add(refName)
        const refDef = schema.defs[refName]
        if (refDef && refDef.properties) {
          for (const nestedProp of Object.values(refDef.properties)) {
            if (checkForDeterministicMath(nestedProp)) {
              return true
            }
          }
        }
      }
    }
    // Check nested properties (e.g., in map values)
    if (propSchema.type === 'object' && propSchema.additionalProperties && typeof propSchema.additionalProperties === 'object') {
      if (checkForDeterministicMath(propSchema.additionalProperties)) {
        return true
      }
    }
    // Check object properties recursively
    if (propSchema.type === 'object' && propSchema.properties) {
      for (const nestedProp of Object.values(propSchema.properties)) {
        if (checkForDeterministicMath(nestedProp)) {
          return true
        }
      }
    }
    return false
  }
  
  const hasDeterministicMath = stateDef && stateDef.properties && 
    Object.values(stateDef.properties).some(prop => checkForDeterministicMath(prop))
  
  // Import action and event payload types, and response types
  const payloadTypes = new Set<string>()
  const responseTypes = new Set<string>()
  for (const action of actions) {
    payloadTypes.add(action.payloadType)
    if (action.responseType) {
      responseTypes.add(action.responseType)
    }
  }
  for (const event of clientEvents) {
    payloadTypes.add(event.payloadType)
  }
  const allTypes = new Set([...payloadTypes, ...responseTypes])
  if (allTypes.size > 0) {
    const sortedTypes = [...allTypes].sort()
    lines.push(`import type { ${sortedTypes.join(', ')} } from '../defs.js'`)
  }
  lines.push('')

  lines.push('interface ConnectOptions {')
  lines.push('  wsUrl: string')
  lines.push('  playerName?: string')
  lines.push('  playerID?: string')
  lines.push('  deviceID?: string')
  lines.push('  landID?: string  // Optional: specify room ID (format: "landType:instanceId" or just "instanceId")')
  lines.push('  metadata?: Record<string, any>')
  lines.push('}')
  lines.push('')

  // Module-level state (singleton pattern)
  lines.push('const runtime = ref<StateTreeRuntime | null>(null)')
  lines.push(`const tree = ref<${className} | null>(null)`)
  lines.push('')
  if (hasDeterministicMath) {
    // For states with DeterministicMath types, use type assertion to avoid type errors
    // SDK automatically converts these types, but TypeScript may not infer correctly
    lines.push(`const state = ref<${stateType} | null>(null) as Ref<${stateType} | null>`)
  } else {
    lines.push(`const state: Ref<${stateType} | null> = ref<${stateType} | null>(null)`)
  }
  lines.push('const currentPlayerID = ref<string | null>(null)')
  lines.push('')
  lines.push('const isConnecting = ref(false)')
  lines.push('const isConnected = ref(false)')
  lines.push('const isJoined = ref(false)')
  lines.push('const lastError = ref<string | null>(null)')
  lines.push('')

  // Generate return type interface
  const returnTypeName = `${classBaseName}ComposableReturn`
  lines.push(`export interface ${returnTypeName} {`)
  lines.push(`  state: Ref<${stateType} | null>`)
  lines.push('  currentPlayerID: Ref<string | null>')
  lines.push('  isConnecting: Ref<boolean>')
  lines.push('  isConnected: Ref<boolean>')
  lines.push('  isJoined: Ref<boolean>')
  lines.push('  lastError: Ref<string | null>')
  lines.push('  connect: (opts: ConnectOptions) => Promise<void>')
  lines.push('  disconnect: () => Promise<void>')
  
  // Add action methods
  for (const action of actions) {
    const actionName = action.propertyName
    const payloadType = action.payloadType
    const responseType = action.responseType ?? 'any'
    lines.push(`  ${actionName}: (payload: ${payloadType}) => Promise<${responseType}>`)
  }
  
  // Add event methods
  for (const event of clientEvents) {
    const eventName = event.propertyName
    const payloadType = event.payloadType
    lines.push(`  ${eventName}: (payload: ${payloadType}) => Promise<void>`)
  }
  
  lines.push(`  tree: ComputedRef<${className} | null>`)
  lines.push('}')
  lines.push('')
  
  lines.push(`export function ${composableName}(): ${returnTypeName} {`)
  lines.push('')
  lines.push('  async function connect(opts: ConnectOptions): Promise<void> {')
  lines.push('    if (isConnecting.value || isConnected.value) return')
  lines.push('')
  lines.push('    isConnecting.value = true')
  lines.push('    lastError.value = null')
  lines.push('')
  lines.push('    try {')
  lines.push('      const r = new StateTreeRuntime()')
  lines.push('      await r.connect(opts.wsUrl)')
  lines.push('      runtime.value = r')
  lines.push('      isConnected.value = true')
  lines.push('')
      lines.push('      const metadata: Record<string, any> = opts.metadata ?? {}')
      lines.push('      if (opts.playerName && opts.playerName.trim().length > 0) {')
      lines.push('        metadata.username = opts.playerName.trim()')
      lines.push('      }')
      lines.push('')
      lines.push('      // Build landID: if provided, use as-is; if it\'s just instanceId (no colon), prepend landType')
      lines.push('      let landID: string | undefined = opts.landID')
      lines.push('      if (landID && !landID.includes(\':\')) {')
      lines.push('        // If only instanceId provided (e.g., "room-123"), prepend landType')
      lines.push('        landID = `${LAND_TYPE}:${landID}`')
      lines.push('      }')
      lines.push('')
      lines.push(`      const t = new ${className}(r, {`)
      lines.push('        landID: landID,')
      lines.push('        playerID: opts.playerID,')
      lines.push('        deviceID: opts.deviceID,')
      lines.push('        metadata,')
  lines.push('        logger: {')
  lines.push('          debug: () => {},')
  lines.push('          info: (msg) => console.log(`[StateTree]`, msg),')
  lines.push('          warn: (msg) => console.warn(`[StateTree]`, msg),')
  lines.push('          error: (msg) => console.error(`[StateTree]`, msg)')
  lines.push('        }')
  lines.push('      })')
  lines.push('      tree.value = t')
  lines.push('')
  lines.push('      const joinResult = await t.join()')
  lines.push('      if (!joinResult.success) {')
  lines.push('        throw new Error(joinResult.reason ?? \'Join failed\')')
  lines.push('      }')
  lines.push('')
      lines.push('      currentPlayerID.value = joinResult.playerID ?? null')
      lines.push('      ')
      lines.push('      // Make t.state reactive so Vue can track changes directly')
      lines.push('      // This allows direct access like state.players[playerID].cookies in templates')
      if (hasDeterministicMath) {
        lines.push('      // Note: SDK automatically converts DeterministicMath types (IVec2, Position2, etc.)')
        lines.push('      // from fixed-point integers to class instances, but TypeScript may not infer this correctly')
        lines.push('      // after reactive() wrapping, so we use type assertion')
        lines.push(`      const reactiveState = reactive(t.state as any) as ${stateType}`)
      } else {
        lines.push(`      const reactiveState = reactive(t.state as ${stateType})`)
      }
      lines.push('      state.value = reactiveState')
  lines.push('      ')
  lines.push('      // Override t.state to point to reactiveState so syncInto updates it directly')
  lines.push('      // This way syncInto will update the reactive object and Vue tracks it automatically')
      lines.push('      Object.defineProperty(t, \'state\', {')
      lines.push('        get: () => reactiveState,')
      lines.push('        enumerable: true,')
      lines.push('        configurable: true')
      lines.push('      })')
      lines.push('      ')
      lines.push('      // Set up disconnect callback for automatic cleanup')
      lines.push('      r.onDisconnect(() => {')
      lines.push('        if (isConnected.value || isJoined.value) {')
      lines.push('          console.warn(\'⚠️ WebSocket disconnected, cleaning up...\')')
      lines.push('          // Update state immediately so watchers can react')
      lines.push('          isConnected.value = false')
      lines.push('          // disconnect() will set isJoined.value = false, triggering watchers')
      lines.push('          disconnect()')
      lines.push('        }')
      lines.push('      })')
      lines.push('      ')
      lines.push('      isJoined.value = true')
  lines.push('    } catch (error) {')
  lines.push('      const message = (error as Error).message ?? String(error)')
  lines.push('      lastError.value = message')
  lines.push('      console.error(\'Connect/join failed:\', error)')
  lines.push('      await disconnect()')
  lines.push('    } finally {')
  lines.push('      isConnecting.value = false')
  lines.push('    }')
  lines.push('  }')
  lines.push('')
  lines.push('  async function disconnect(): Promise<void> {')
  lines.push('    if (tree.value) {')
  lines.push('      tree.value.destroy()')
  lines.push('    }')
  lines.push('    if (runtime.value && \'disconnect\' in runtime.value && typeof runtime.value.disconnect === \'function\') {')
  lines.push('      runtime.value.disconnect()')
  lines.push('    }')
  lines.push('    runtime.value = null')
  lines.push('    tree.value = null')
  lines.push('    state.value = null')
  lines.push('    currentPlayerID.value = null')
  lines.push('    isConnected.value = false')
  lines.push('    isJoined.value = false')
  lines.push('  }')
  lines.push('')

  // Generate action wrappers
  for (const action of actions) {
    const actionName = action.propertyName
    const payloadType = action.payloadType
    const responseType = action.responseType ?? 'any'
    lines.push(`  async function ${actionName}(payload: ${payloadType}): Promise<${responseType}> {`)
    lines.push('    if (!tree.value || !isJoined.value) {')
    lines.push(`      throw new Error('Not connected or not joined')`)
    lines.push('    }')
    lines.push('    try {')
    lines.push(`      const res = await tree.value.actions.${actionName}(payload)`)
    lines.push('      lastError.value = null')
    lines.push('      return res')
    lines.push('    } catch (error) {')
    lines.push(`      console.error('${actionName} failed:', error)`)
    lines.push('      lastError.value = (error as Error).message ?? String(error)')
    lines.push('      throw error')
    lines.push('    }')
    lines.push('  }')
    lines.push('')
  }

  // Generate event wrappers
  for (const event of clientEvents) {
    const eventName = event.propertyName
    const payloadType = event.payloadType
    lines.push(`  async function ${eventName}(payload: ${payloadType}): Promise<void> {`)
    lines.push('    if (!tree.value || !isJoined.value) return')
    lines.push('    try {')
    lines.push(`      await tree.value.events.${eventName}(payload)`)
    lines.push('      lastError.value = null')
    lines.push('    } catch (error) {')
    lines.push(`      console.error('${eventName} failed:', error)`)
    lines.push('      lastError.value = (error as Error).message ?? String(error)')
    lines.push('    }')
    lines.push('  }')
    lines.push('')
  }

  // Return object
  lines.push('  return {')
  lines.push('    state,')
  lines.push('    currentPlayerID,')
  lines.push('    isConnecting,')
  lines.push('    isConnected,')
  lines.push('    isJoined,')
  lines.push('    lastError,')
  lines.push('    connect,')
  lines.push('    disconnect,')

  // Add action methods
  for (const action of actions) {
    lines.push(`    ${action.propertyName},`)
  }

  // Add event methods
  for (const event of clientEvents) {
    lines.push(`    ${event.propertyName},`)
  }

  // Also expose tree for advanced usage
  lines.push('    // Advanced: access to underlying tree instance')
  lines.push(`    tree: computed(() => tree.value) as ComputedRef<${className} | null>`)
  lines.push('  }')
  lines.push('}')
  lines.push('')

  return lines.join('\n')
}

function inferResponseType(payloadType: string, defNames: Set<string>): string | undefined {
  const candidates: string[] = []

  if (payloadType.endsWith('Action')) {
    const base = payloadType.slice(0, -'Action'.length)
    candidates.push(`${base}Response`)
  }

  if (payloadType.endsWith('Request')) {
    const base = payloadType.slice(0, -'Request'.length)
    candidates.push(`${base}Response`)
  }

  for (const candidate of candidates) {
    if (defNames.has(candidate)) {
      return candidate
    }
  }

  return undefined
}

/**
 * Generate test helpers for a land.
 * This generates mock utilities and test helpers based on the schema structure.
 */
function generateTestHelpers(
  schema: ProtocolSchema,
  landID: string,
  landDef: LandDefinition,
  classBaseName: string,
  composableName: string | undefined,
  actions: ActionBinding[],
  clientEvents: EventBinding[],
  stateType: string,
  testFramework?: TestFramework
): string | null {
  const lines: string[] = []
  lines.push(generateHeader())
  
  lines.push("import { ref, computed } from 'vue'")
  lines.push(`import type { ${stateType} } from '../defs.js'`)
  
  // Check if state uses DeterministicMath types and import them
  const stateDefForImports = schema.defs[stateType]
  const deterministicMathTypes = new Set<string>()
  if (stateDefForImports && stateDefForImports.properties) {
    const checkForDeterministicMath = (propSchema: SchemaProperty) => {
      if (propSchema.$ref) {
        const refName = resolveRefName(propSchema.$ref)
        if (isDeterministicMathType(refName)) {
          deterministicMathTypes.add(refName)
        }
      }
      if (propSchema.type === 'object' && propSchema.properties) {
        for (const prop of Object.values(propSchema.properties)) {
          checkForDeterministicMath(prop)
        }
      }
      if (propSchema.type === 'object' && propSchema.additionalProperties && typeof propSchema.additionalProperties === 'object') {
        checkForDeterministicMath(propSchema.additionalProperties)
      }
    }
    for (const propSchema of Object.values(stateDefForImports.properties)) {
      checkForDeterministicMath(propSchema)
    }
  }
  if (deterministicMathTypes.size > 0) {
    const sortedTypes = [...deterministicMathTypes].sort()
    lines.push(`import { ${sortedTypes.join(', ')} } from '@swiftstatetree/sdk/core'`)
  }
  
  // Import action and event types
  const payloadTypes = new Set<string>()
  const responseTypes = new Set<string>()
  for (const action of actions) {
    payloadTypes.add(action.payloadType)
    if (action.responseType) {
      responseTypes.add(action.responseType)
    }
  }
  for (const event of clientEvents) {
    payloadTypes.add(event.payloadType)
  }
  const allTypes = new Set([...payloadTypes, ...responseTypes])
  if (allTypes.size > 0) {
    const sortedTypes = [...allTypes].sort()
    lines.push(`import type { ${sortedTypes.join(', ')} } from '../defs.js'`)
  }
  
  // Import test framework if specified
  if (testFramework === 'vitest') {
    lines.push("import { vi } from 'vitest'")
  } else if (testFramework === 'jest') {
    lines.push("// Jest mocks would go here")
  }
  
  lines.push('')
  
  // Generate createMockState function
  lines.push('/**')
  lines.push(' * Creates a mock state for testing.')
  lines.push(' * Automatically generates default values based on the state type structure.')
  lines.push(' */')
  lines.push(`export function createMockState(overrides?: Partial<${stateType}>): ${stateType} {`)
  lines.push('  return {')
  
  // Analyze state type structure and generate defaults
  const stateDef = schema.defs[stateType]
  if (stateDef && stateDef.properties) {
    const ctx: TypeMapperContext = { knownDefs: new Set(Object.keys(schema.defs)) }
    for (const [propName, propSchema] of Object.entries(stateDef.properties)) {
      const defaultValue = generateDefaultValue(propSchema, ctx, schema)
      lines.push(`    ${propName}: ${defaultValue},`)
    }
  } else {
    // Fallback: empty object with type assertion
    lines.push('    // State structure will be inferred from overrides')
  }
  
  lines.push('    ...overrides')
  lines.push('  }')
  lines.push('}')
  lines.push('')
  
  // Generate mock composable if composable exists
  if (composableName) {
    lines.push('/**')
    lines.push(' * Creates a mock composable for testing.')
    lines.push(' * This provides a fully functional mock of the composable with reactive state.')
    lines.push(' */')
    lines.push(`export function createMock${classBaseName}(initialState?: ${stateType}) {`)
    lines.push(`  const state = ref<${stateType} | null>(initialState || createMockState())`)
    lines.push("  const currentPlayerID = ref<string | null>('test-player-1')")
    lines.push('  const isConnecting = ref(false)')
    lines.push('  const isConnected = ref(true)')
    lines.push('  const isJoined = ref(true)')
    lines.push('  const lastError = ref<string | null>(null)')
    lines.push('')
    
    // Generate mock functions for client events
    const mockFn = testFramework === 'vitest' ? 'vi.fn' : testFramework === 'jest' ? 'jest.fn' : '(() => {})'
    for (const event of clientEvents) {
      const eventName = event.propertyName
      const eventPayloadType = event.payloadType
      lines.push(`  const ${eventName} = ${mockFn}(async (_payload: ${eventPayloadType}) => {`)
      lines.push('    // Mock implementation - customize as needed')
      lines.push('  })')
      lines.push('')
    }
    
    // Generate mock functions for actions
    for (const action of actions) {
      const actionName = action.propertyName
      const actionPayloadType = action.payloadType
      const actionResponseType = action.responseType || 'any'
      lines.push(`  const ${actionName} = ${mockFn}(async (_payload: ${actionPayloadType}): Promise<${actionResponseType}> => {`)
      lines.push('    // Mock implementation - customize as needed')
      if (action.responseType) {
        lines.push(`    return {} as ${actionResponseType}`)
      } else {
        lines.push('    return {} as any')
      }
      lines.push('  })')
      lines.push('')
    }
    
    lines.push(`  const disconnect = ${mockFn}(async () => {`)
    lines.push('    isConnected.value = false')
    lines.push('    isJoined.value = false')
    lines.push('    state.value = null')
    lines.push('  })')
    lines.push('')
    
    lines.push('  return {')
    lines.push('    state,')
    lines.push('    currentPlayerID,')
    lines.push('    isConnecting,')
    lines.push('    isConnected,')
    lines.push('    isJoined,')
    lines.push('    lastError,')
    
    // Add all event functions
    for (const event of clientEvents) {
      lines.push(`    ${event.propertyName},`)
    }
    
    // Add all action functions
    for (const action of actions) {
      lines.push(`    ${action.propertyName},`)
    }
    
    lines.push('    disconnect,')
    lines.push(`    connect: ${mockFn}(),`)
    lines.push('    tree: computed(() => null)')
    lines.push('  }')
    lines.push('}')
    lines.push('')
  }
  
  // Generate high-level helpers if test framework is specified
  if (testFramework === 'vitest' && composableName) {
    const stateDef = schema.defs[stateType]
    if (!stateDef?.properties) {
      return lines.join('\n')
    }
    
    // Find all first-level map properties (objects with additionalProperties)
    // Generate helper for each map property
    for (const [mapPropName, mapPropSchema] of Object.entries(stateDef.properties)) {
      // Only generate helpers for map types (objects with additionalProperties)
      if (mapPropSchema.type !== 'object' || !mapPropSchema.additionalProperties) {
        continue
      }
      
      const additionalProps = mapPropSchema.additionalProperties
      if (typeof additionalProps !== 'object') {
        continue
      }
      
      // Determine value type
      let valueType: string | null = null
      let isPrimitive = false
      
      if (additionalProps.type) {
        const type = additionalProps.type
        if (type === 'string' || type === 'number' || type === 'boolean' || type === 'integer') {
          isPrimitive = true
          valueType = type === 'integer' ? 'number' : type
        }
      } else if (additionalProps.$ref) {
        valueType = resolveRefName(additionalProps.$ref)
      }
      
      if (!valueType) {
        continue
      }
      
      // Generate helper function name and parameter names
      // Convert map name to singular (e.g., "players" -> "player", "privateStates" -> "privateState")
      const singularName = mapPropName.endsWith('s') && mapPropName.length > 1 
        ? mapPropName.slice(0, -1) 
        : mapPropName
      const pascalSingular = toPascalCase(singularName)
      const camelSingular = lowerFirst(pascalSingular)
      const itemIDName = camelSingular + 'ID'
      const itemDataName = camelSingular + 'Data'
      const itemValueName = camelSingular + 'Value'
      
      // Generate helper function
      lines.push('/**')
      lines.push(` * High-level test helper for ${mapPropName}.`)
      lines.push(' * Provides a simple API for setting up component tests.')
      lines.push(' */')
      
      if (isPrimitive) {
        // If map value is a primitive type, use it directly
        lines.push(`export function testWith${classBaseName}${pascalSingular}(`)
        lines.push(`  ${itemIDName}: string,`)
        lines.push(`  ${itemValueName}?: ${valueType}`)
        lines.push(') {')
        lines.push(`  const mockState = createMockState({`)
        lines.push(`    ${mapPropName}: {`)
        if (valueType === 'string') {
          lines.push(`      [${itemIDName}]: ${itemValueName} ?? \`${singularName} \$\{${itemIDName}\}\``)
        } else {
          lines.push(`      [${itemIDName}]: ${itemValueName} ?? 0`)
        }
        lines.push('    }')
        lines.push('  })')
      } else {
        // If map value is an object, generate defaults for all required properties
        // Check if this is a DeterministicMath type (Position2, Velocity2, Acceleration2)
        if (isDeterministicMathType(valueType)) {
          // For DeterministicMath types, use class constructor directly
          let constructorCall = ''
          if (valueType === 'Position2') {
            constructorCall = 'new Position2({ x: 0, y: 0 }, false)'
          } else if (valueType === 'Velocity2') {
            constructorCall = 'new Velocity2({ x: 0, y: 0 }, false)'
          } else if (valueType === 'Acceleration2') {
            constructorCall = 'new Acceleration2({ x: 0, y: 0 }, false)'
          } else {
            // Fallback for other DeterministicMath types
            constructorCall = `new ${valueType}(0, 0)`
          }
          
          lines.push(`export function testWith${classBaseName}${pascalSingular}(`)
          lines.push(`  ${itemIDName}: string,`)
          lines.push(`  ${itemDataName}?: ${valueType}`)
          lines.push(') {')
          lines.push(`  const mockState = createMockState({`)
          lines.push(`    ${mapPropName}: {`)
          lines.push(`      [${itemIDName}]: ${itemDataName} ?? ${constructorCall}`)
          lines.push('    }')
          lines.push('  })')
        } else {
          // If map value is a regular object, generate defaults for all required properties
          let itemDefaults: string[] = []
          const itemTypeDef = schema.defs[valueType]
          if (itemTypeDef && itemTypeDef.properties) {
            const ctx: TypeMapperContext = { knownDefs: new Set(Object.keys(schema.defs)) }
            const requiredProps = new Set(itemTypeDef.required || [])
            
            for (const [itemPropName, itemPropSchema] of Object.entries(itemTypeDef.properties)) {
              const isRequired = requiredProps.has(itemPropName)
              const defaultValue = generateDefaultValue(itemPropSchema, ctx, schema)
              
              if (isRequired) {
                // Special handling for 'name' property
                if (itemPropName === 'name') {
                  itemDefaults.push(`${itemPropName}: ${itemDataName}?.${itemPropName} ?? \`${singularName} \$\{${itemIDName}\}\``)
                } else {
                  itemDefaults.push(`${itemPropName}: ${itemDataName}?.${itemPropName} ?? ${defaultValue}`)
                }
              } else {
                itemDefaults.push(`${itemPropName}: ${itemDataName}?.${itemPropName} !== undefined ? ${itemDataName}.${itemPropName} : ${defaultValue}`)
              }
            }
          }
          
          lines.push(`export function testWith${classBaseName}${pascalSingular}(`)
          lines.push(`  ${itemIDName}: string,`)
          lines.push(`  ${itemDataName}?: Partial<${stateType}['${mapPropName}'][string]>`)
          lines.push(') {')
          lines.push(`  const mockState = createMockState({`)
          lines.push(`    ${mapPropName}: {`)
          if (itemDefaults.length > 0) {
            lines.push(`      [${itemIDName}]: {`)
            for (const defaultLine of itemDefaults) {
              lines.push(`        ${defaultLine},`)
            }
            lines.push('      } as ' + stateType + `['${mapPropName}'][string]`)
          } else {
            // Fallback
            lines.push(`      [${itemIDName}]: {`)
            lines.push(`        ...(${itemDataName} as ${stateType}['${mapPropName}'][string]),`)
            lines.push(`        name: ${itemDataName}?.name ?? \`${singularName} \$\{${itemIDName}\}\``)
            lines.push('      } as ' + stateType + `['${mapPropName}'][string]`)
          }
          lines.push('    }')
          lines.push('  })')
        }
      }
      
      lines.push(`  const mockComposable = createMock${classBaseName}(mockState)`)
      // Only set currentPlayerID if this is the 'players' map
      if (mapPropName === 'players') {
        lines.push(`  mockComposable.currentPlayerID.value = ${itemIDName}`)
      }
      lines.push('  return mockComposable')
      lines.push('}')
      lines.push('')
    }
  }
  
  return lines.join('\n')
}

/**
 * Generate a default value for a schema property.
 * Analyzes the type and generates appropriate default values.
 */
function generateDefaultValue(
  propSchema: SchemaProperty,
  ctx: TypeMapperContext,
  schema: ProtocolSchema
): string {
  // Handle $ref
  if (propSchema.$ref) {
    const refName = resolveRefName(propSchema.$ref)
    
    // Check if this is a DeterministicMath type
    if (isDeterministicMathType(refName)) {
      // Generate class instance constructor
      if (refName === 'IVec2') {
        return 'new IVec2(0, 0)'
      } else if (refName === 'IVec3') {
        return 'new IVec3(0, 0, 0)'
      } else if (refName === 'Position2') {
        return 'new Position2({ x: 0, y: 0 }, false)'
      } else if (refName === 'Velocity2') {
        return 'new Velocity2({ x: 0, y: 0 }, false)'
      } else if (refName === 'Acceleration2') {
        return 'new Acceleration2({ x: 0, y: 0 }, false)'
      } else if (refName === 'Angle') {
        return 'new Angle(0, false)'
      }
    }
    
    const refDef = schema.defs[refName]
    if (refDef) {
      return generateDefaultValueForDef(refDef, ctx, schema)
    }
    return '{} as any'
  }
  
  const type = propSchema.type
  
  switch (type) {
    case 'string':
      return "''"
    case 'integer':
    case 'number':
      return '0'
    case 'boolean':
      return 'false'
    case 'null':
      return 'null'
    case 'array':
      if (propSchema.items) {
        return '[]'
      }
      return '[]'
    case 'object':
      if (propSchema.properties) {
        const props: string[] = []
        for (const [name, subProp] of Object.entries(propSchema.properties)) {
          const defaultValue = generateDefaultValue(subProp, ctx, schema)
          props.push(`${name}: ${defaultValue}`)
        }
        return `{ ${props.join(', ')} }`
      }
      return '{}'
    default:
      return '{} as any'
  }
}

/**
 * Check if a type name is a DeterministicMath type.
 */
function isDeterministicMathType(name: string): boolean {
  return ['IVec2', 'IVec3', 'Position2', 'Velocity2', 'Acceleration2', 'Angle'].includes(name)
}

/**
 * Generate default value for a SchemaDef (used for $ref types).
 */
function generateDefaultValueForDef(
  def: SchemaDef,
  ctx: TypeMapperContext,
  schema: ProtocolSchema
): string {
  if (def.$ref) {
    const refName = resolveRefName(def.$ref)
    
    // Check if this is a DeterministicMath type
    if (isDeterministicMathType(refName)) {
      // Generate class instance constructor
      if (refName === 'IVec2') {
        return 'new IVec2(0, 0)'
      } else if (refName === 'IVec3') {
        return 'new IVec3(0, 0, 0)'
      } else if (refName === 'Position2') {
        return 'new Position2({ x: 0, y: 0 }, false)'
      } else if (refName === 'Velocity2') {
        return 'new Velocity2({ x: 0, y: 0 }, false)'
      } else if (refName === 'Acceleration2') {
        return 'new Acceleration2({ x: 0, y: 0 }, false)'
      } else if (refName === 'Angle') {
        return 'new Angle(0, false)'
      }
    }
    
    const refDef = schema.defs[refName]
    if (refDef) {
      return generateDefaultValueForDef(refDef, ctx, schema)
    }
    return '{} as any'
  }

  const type = def.type

  switch (type) {
    case 'string':
      return "''"
    case 'integer':
    case 'number':
      return '0'
    case 'boolean':
      return 'false'
    case 'null':
      return 'null'
    case 'array':
      return '[]'
    case 'object':
      if (def.properties) {
        const props: string[] = []
        for (const [name, prop] of Object.entries(def.properties)) {
          const defaultValue = generateDefaultValue(prop, ctx, schema)
          props.push(`${name}: ${defaultValue}`)
        }
        return `{ ${props.join(', ')} }`
      }
      // Handle additionalProperties (dictionary)
      if (def.additionalProperties) {
        if (def.additionalProperties === true) {
          return '{}'
        } else if (typeof def.additionalProperties === 'object') {
          const valueDefault = generateDefaultValueForDef(def.additionalProperties, ctx, schema)
          return `{} as Record<string, typeof (${valueDefault})>`
        }
      }
      return '{}'
    default:
      return '{} as any'
  }
}
