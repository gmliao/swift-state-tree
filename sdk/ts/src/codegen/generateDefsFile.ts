import type { ProtocolSchema } from './schema.js'
import { mapSchemaDefToTsType, type TypeMapperContext } from './typeMapper.js'
import { isOptionalType } from './schema.js'

function generateHeader(): string {
  return [
    '// AUTO-GENERATED BY @swiftstatetree/sdk codegen.',
    '// Do not edit this file directly.',
    '',
  ].join('\n')
}

/**
 * Check if a type name is a DeterministicMath type that needs conversion helpers.
 */
function isDeterministicMathType(name: string): boolean {
  return ['IVec2', 'IVec3', 'Position2', 'Velocity2', 'Acceleration2', 'Angle'].includes(name)
}

/**
 * Generate conversion helpers for DeterministicMath types.
 * Note: IVec2/IVec3/Position2/Velocity2/Acceleration2 conversion is handled automatically by SDK.
 * Only Angle conversion helpers are generated (for degrees/radians conversion).
 */
function generateDeterministicMathHelpers(schema: ProtocolSchema): string {
  const lines: string[] = []
  
  // Fixed-point scale (must match Swift FixedPoint.scale)
  const SCALE = 1000
  
  const hasAngle = 'Angle' in schema.defs
  
  if (!hasAngle) {
    return ''
  }
  
  lines.push('// Angle conversion helpers (for degrees/radians conversion)')
  lines.push('// Note: Angle class automatically handles fixed-point to float conversion.')
  lines.push('// These helpers only convert between degrees and radians.')
  lines.push('')
  
  if (hasAngle) {
    lines.push('/**')
    lines.push(' * Convert Angle to radians.')
    lines.push(' * @param angle - The Angle instance (degrees getter automatically returns float)')
    lines.push(' * @returns Angle in radians as float')
    lines.push(' * @example')
    lines.push(' * const angle = new Angle(45000, true) // fixed-point integer')
    lines.push(' * const rad = AngleToRadians(angle) // ≈ 0.785 (π/4)')
    lines.push(' */')
    lines.push('export function AngleToRadians(angle: Angle): number {')
    lines.push('  return angle.degrees * Math.PI / 180')
    lines.push('}')
    lines.push('')
    
    lines.push('/**')
    lines.push(' * Convert Angle to degrees (float).')
    lines.push(' * @param angle - The Angle instance (degrees getter automatically returns float)')
    lines.push(' * @returns Angle in degrees as float')
    lines.push(' * @example')
    lines.push(' * const angle = new Angle(45000, true) // fixed-point integer')
    lines.push(' * const deg = AngleToDegrees(angle) // 45.0')
    lines.push(' */')
    lines.push('export function AngleToDegrees(angle: Angle): number {')
    lines.push('  return angle.degrees')
    lines.push('}')
    lines.push('')
    
    lines.push('/**')
    lines.push(' * Convert radians to Angle.')
    lines.push(' * @param radians - Angle in radians as float')
    lines.push(' * @returns Angle instance (degrees setter automatically converts to fixed-point)')
    lines.push(' * @example')
    lines.push(' * const angle = RadiansToAngle(Math.PI / 4) // new Angle(45.0, false)')
    lines.push(' */')
    lines.push('export function RadiansToAngle(radians: number): Angle {')
    lines.push('  const degrees = radians * 180 / Math.PI')
    lines.push('  return new Angle(degrees, false) // false = float input')
    lines.push('}')
    lines.push('')
    
    lines.push('/**')
    lines.push(' * Convert degrees to Angle.')
    lines.push(' * @param degrees - Angle in degrees as float')
    lines.push(' * @returns Angle instance (degrees setter automatically converts to fixed-point)')
    lines.push(' * @example')
    lines.push(' * const angle = DegreesToAngle(45.0) // new Angle(45.0, false)')
    lines.push(' */')
    lines.push('export function DegreesToAngle(degrees: number): Angle {')
    lines.push('  return new Angle(degrees, false) // false = float input')
    lines.push('}')
    lines.push('')
  }
  
  return lines.join('\n')
}

// Note: DeterministicMath classes (IVec2, IVec3, Angle, Position2, etc.) are now
// defined in SDK core (sdk/ts/src/core/deterministic-math.ts) and imported from there.
// This avoids code duplication and ensures consistency.

/**
 * Generate the contents of defs.ts.
 */
export function generateDefsTs(schema: ProtocolSchema): string {
  const lines: string[] = []
  lines.push(generateHeader())

  const defNames = Object.keys(schema.defs)
  const ctx: TypeMapperContext = {
    knownDefs: new Set(defNames)
  }

  // Keep output stable by sorting definition names.
  const sortedDefNames = [...defNames].sort()

  // Import DeterministicMath classes from SDK instead of generating them
  const hasIVec2 = 'IVec2' in schema.defs
  const hasIVec3 = 'IVec3' in schema.defs
  const hasAngle = 'Angle' in schema.defs
  const hasPosition2 = 'Position2' in schema.defs
  const hasVelocity2 = 'Velocity2' in schema.defs
  const hasAcceleration2 = 'Acceleration2' in schema.defs

  const imports: string[] = []
  if (hasIVec2) imports.push('IVec2')
  if (hasIVec3) imports.push('IVec3')
  if (hasAngle) imports.push('Angle')
  if (hasPosition2) imports.push('Position2')
  if (hasVelocity2) imports.push('Velocity2')
  if (hasAcceleration2) imports.push('Acceleration2')
  
  if (imports.length > 0) {
    lines.push('// Import DeterministicMath classes from SDK')
    lines.push('// These classes automatically convert fixed-point integers to floats via getters')
    // Add @ts-ignore to suppress false positive warnings about unused imports
    // These classes are used in type definitions below, but TypeScript doesn't recognize them as "used"
    // when they're only in type positions (which is valid usage)
    lines.push(`// @ts-ignore - Classes are used in type definitions below`)
    lines.push(`import { ${imports.join(', ')}, FIXED_POINT_SCALE } from '@swiftstatetree/sdk/core'`)
    lines.push('')
    // Re-export the classes so they can be imported from defs.ts
    // Note: Classes are used both as types (in type definitions) and as values (for instantiation)
    for (const imp of imports) {
      lines.push(`export { ${imp} }`)
    }
    lines.push('export { FIXED_POINT_SCALE }')
    lines.push('')
  } else {
    // Still export FIXED_POINT_SCALE for Angle helpers
    lines.push('// Fixed-point scale factor (matches Swift FixedPoint.scale)')
    lines.push('export const FIXED_POINT_SCALE = 1000')
    lines.push('')
  }

  // Track Optional types to generate a single generic type definition
  const optionalTypes = new Set<string>()
  const nonOptionalDefs: string[] = []

  // Separate Optional types from regular types
  for (const name of sortedDefNames) {
    // Skip DeterministicMath types - they are classes now
    if (isDeterministicMathType(name)) {
      continue
    }
    if (isOptionalType(name)) {
      optionalTypes.add(name)
    } else {
      nonOptionalDefs.push(name)
    }
  }

  // Generate type definitions for non-Optional types
  for (const name of nonOptionalDefs) {
    const def = schema.defs[name]
    
    // Special handling for PlayerID: Swift struct has rawValue: String property
    // but schema may not include it, so we define it explicitly
    if (name === 'PlayerID') {
      lines.push('// PlayerID is a Swift struct with rawValue: String property')
      lines.push('export type PlayerID = { rawValue: string }')
      continue
    }
    
    const tsType = mapSchemaDefToTsType(def, ctx)
    // Add @ts-ignore for types that use DeterministicMath classes in type positions
    // This suppresses TypeScript's false positive warnings about unused imports
    // Check if the type definition uses any DeterministicMath class
    const usedClasses = imports.filter(imp => {
      // Check if the type string contains the class name (as a type reference)
      // OR if the type name itself contains the class name (e.g., "Optional<Position2>")
      return (tsType.includes(imp) && !tsType.includes(`typeof ${imp}`)) || name.includes(imp)
    })
    if (usedClasses.length > 0) {
      lines.push(`// @ts-ignore - DeterministicMath classes (${usedClasses.join(', ')}) are used in type definitions`)
    }
    lines.push(`export type ${name} = ${tsType}`)
  }

  // Generate a single generic Optional type if any Optional types exist
  if (optionalTypes.size > 0) {
    lines.push('')
    lines.push('// Generic Optional type for all Optional<T> usages')
    lines.push('export type Optional<T> = T | null | undefined')
  }

  if (lines[lines.length - 1] !== '') {
    lines.push('')
  }

  // Generate conversion helpers for Angle (degrees/radians conversion)
  const helpers = generateDeterministicMathHelpers(schema)
  if (helpers) {
    lines.push(helpers)
  }

  return lines.join('\n')
}

