feat: complete Phase 2 path hash encoder/decoder

Implements PathHash compression for state updates with automatic format detection
and backward compatibility.

## Changes

### Server (Swift)

- **OpcodeJSONStateUpdateEncoder**: Added optional PathHasher parameter
  - Legacy format: `[path, op, value?]`
  - PathHash format: `[pathHash, dynamicKey, op, value?]`
  - Backward compatible (nil pathHasher = legacy format)

### Client (TypeScript)

- **protocol.ts**: Enhanced decoder with automatic format detection
  - Detects format based on first element type (string vs number)
  - Added `reconstructPath()` function for hash→path conversion
  - Exported `pathHashReverseLookup` Map for reverse lookup
- **view.ts**: Initialize pathHashReverseLookup from schema.pathHashes
  - Automatic population during View construction
  - No client-side configuration needed

### Documentation

- **TRANSPORT_PROTOCOL.md**: Comprehensive PathHash format documentation
  - Format comparison (Legacy vs PathHash)
  - Configuration examples (Swift & TypeScript)
  - Performance comparison table
  - Bandwidth savings: **76%** (55 bytes → 13 bytes with PlayerSlot)

## Format Examples

### Legacy Format
```json
[2, "player-123", ["/players/player-123/hp", 1, 90]]
```

### PathHash Format
```json
[2, "player-123", [2558331159, "42", 1, 90]]
```

### PathHash + PlayerSlot (Optimal)
- Path compression: ~30 bytes → 4 bytes
- PlayerID compression: 36 bytes → 4 bytes
- Total savings: **76%** bandwidth reduction

## Tests

- Swift: 601/601 passing ✓
- TypeScript SDK: 96/96 passing ✓
- Automatic format detection verified
- Backward compatibility maintained

## Breaking Changes

None - both formats are supported simultaneously with automatic detection.

## Files Modified

- Sources/SwiftStateTreeTransport/StateUpdateEncoder.swift
- sdk/ts/src/core/protocol.ts
- sdk/ts/src/core/view.ts
- Notes/protocol/TRANSPORT_PROTOCOL.md
