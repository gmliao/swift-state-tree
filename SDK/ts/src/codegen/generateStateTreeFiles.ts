import { join } from 'node:path'
import type { LandDefinition, ProtocolSchema } from './schema.js'
import { resolveRefName } from './typeMapper.js'
import { writeFileRecursive } from './writeFile.js'

interface ActionBinding {
  id: string
  payloadType: string
  propertyName: string
  responseType?: string
}

interface EventBinding {
  id: string
  payloadType: string
  propertyName: string
}

function generateHeader(): string {
  return [
    '// AUTO-GENERATED BY @swiftstatetree/sdk codegen.',
    '// Do not edit this file directly.',
    ''
  ].join('\n')
}

export async function generateStateTreeFiles(schema: ProtocolSchema, outputDir: string): Promise<void> {
  for (const [landID, landDef] of Object.entries(schema.lands)) {
    await generateForLand(schema, landID, landDef, outputDir)
  }
}

async function generateForLand(schema: ProtocolSchema, landID: string, landDef: LandDefinition, outputDir: string): Promise<void> {
  const landDir = join(outputDir, landID)
  const classBaseName = toPascalCase(landID)
  const className = `${classBaseName}StateTree`

  const actions = collectActionBindings(schema, landDef)
  const clientEvents = collectEventBindings(landDef.clientEvents)
  const serverEvents = collectEventBindings(landDef.events)

  const bindingsSource = generateBindingsTs(schema, landID, landDef, actions, clientEvents, serverEvents)
  const indexSource = generateIndexTs(landID, className, actions, clientEvents, serverEvents)

  await writeFileRecursive(join(landDir, 'bindings.ts'), bindingsSource)
  await writeFileRecursive(join(landDir, 'index.ts'), indexSource)
}

function collectActionBindings(schema: ProtocolSchema, landDef: LandDefinition): ActionBinding[] {
  const result: ActionBinding[] = []
  const actions = landDef.actions ?? {}
  const defNames = new Set(Object.keys(schema.defs))

  for (const [id, ref] of Object.entries(actions)) {
    const payloadType = resolveRefName(ref.$ref)
    const propertyName = toActionPropertyName(payloadType, id)
    const responseType = inferResponseType(payloadType, defNames)
    result.push({ id, payloadType, propertyName, responseType })
  }

  return result
}

function collectEventBindings(events?: Record<string, { $ref: string }>): EventBinding[] {
  const result: EventBinding[] = []
  if (!events) return result

  for (const [id, ref] of Object.entries(events)) {
    const payloadType = resolveRefName(ref.$ref)
    const propertyName = toEventPropertyName(payloadType, id)
    // Use the full type name (e.g., "ClickCookieEvent") as the event ID
    // instead of the short schema ID (e.g., "ClickCookie")
    result.push({ id: payloadType, payloadType, propertyName })
  }

  return result
}

function generateBindingsTs(
  schema: ProtocolSchema,
  landID: string,
  landDef: LandDefinition,
  actions: ActionBinding[],
  clientEvents: EventBinding[],
  serverEvents: EventBinding[]
): string {
  const lines: string[] = []
  lines.push(generateHeader())

  const importTypes = new Set<string>()
  importTypes.add(landDef.stateType)
  for (const a of actions) {
    importTypes.add(a.payloadType)
    if (a.responseType) {
      importTypes.add(a.responseType)
    }
  }
  for (const e of clientEvents) {
    importTypes.add(e.payloadType)
  }
  for (const e of serverEvents) {
    importTypes.add(e.payloadType)
  }

  const sortedImportTypes = [...importTypes].sort()
  if (sortedImportTypes.length > 0) {
    lines.push(`import type { ${sortedImportTypes.join(', ')} } from '../defs'`)
    lines.push('')
  }

  lines.push(`export const LAND_TYPE = ${JSON.stringify(landID)} as const`)
  lines.push('')

  lines.push(`export type LandState = ${landDef.stateType}`)
  lines.push('')

  // Actions
  lines.push('export interface ActionPayloads {')
  for (const a of actions) {
    lines.push(`  ${a.propertyName}: ${a.payloadType}`)
  }
  lines.push('}')
  lines.push('')

  lines.push('export interface ActionResponses {')
  for (const a of actions) {
    const responseType = a.responseType ?? 'any'
    lines.push(`  ${a.propertyName}: ${responseType}`)
  }
  lines.push('}')
  lines.push('')

  lines.push('export type ActionName = keyof ActionPayloads')
  lines.push('')

  // Client events
  lines.push('export interface ClientEventPayloads {')
  for (const e of clientEvents) {
    lines.push(`  ${e.propertyName}: ${e.payloadType}`)
  }
  lines.push('}')
  lines.push('')

  lines.push('export type ClientEventName = keyof ClientEventPayloads')
  lines.push('')

  // Server events
  lines.push('export interface ServerEventPayloads {')
  for (const e of serverEvents) {
    lines.push(`  ${e.propertyName}: ${e.payloadType}`)
  }
  lines.push('}')
  lines.push('')

  lines.push('export type ServerEventName = keyof ServerEventPayloads')
  lines.push('')

  lines.push('export type Actions = {')
  lines.push('  [K in ActionName]: (payload: ActionPayloads[K]) => Promise<ActionResponses[K]>')
  lines.push('}')
  lines.push('')

  lines.push('export type ClientEvents = {')
  lines.push('  [K in ClientEventName]: (payload: ClientEventPayloads[K]) => void')
  lines.push('}')
  lines.push('')

  lines.push('export type ServerEventSubscriptions = {')
  lines.push('  [K in ServerEventName]: (handler: (payload: ServerEventPayloads[K]) => void) => () => void')
  lines.push('}')
  lines.push('')

  return lines.join('\n')
}

function generateIndexTs(
  landID: string,
  className: string,
  actions: ActionBinding[],
  clientEvents: EventBinding[],
  serverEvents: EventBinding[]
): string {
  const lines: string[] = []
  lines.push(generateHeader())

  lines.push(`import type { StateTreeRuntime, Logger } from '@swiftstatetree/sdk/core'`)
  lines.push(`import { StateTreeView } from '@swiftstatetree/sdk/core'`)
  lines.push(
    `import type { LandState, Actions, ClientEvents, ServerEventSubscriptions } from './bindings'`
  )
  lines.push(`import { LAND_TYPE } from './bindings'`)
  lines.push('')

  lines.push('export interface StateTreeOptions {')
  lines.push('  landID?: string')
  lines.push('  playerID?: string')
  lines.push('  deviceID?: string')
  lines.push('  metadata?: Record<string, any>')
  lines.push('  logger?: Logger')
  lines.push('}')
  lines.push('')

  lines.push(`export class ${className} {`)
  lines.push('  readonly landType = LAND_TYPE')
  lines.push('  readonly state: LandState')
  lines.push('  readonly actions: Actions')
  lines.push('  readonly events: ClientEvents')
  lines.push('  readonly on: ServerEventSubscriptions')
  lines.push('')
  lines.push('  private readonly runtime: StateTreeRuntime')
  lines.push('  private readonly view: StateTreeView')
  lines.push('')

  lines.push('  constructor(runtime: StateTreeRuntime, options?: StateTreeOptions) {')
  lines.push('    this.runtime = runtime')
  lines.push('    const landID = options?.landID ?? LAND_TYPE')
  lines.push('    this.state = {} as LandState')
  lines.push('')
  lines.push('    this.view = runtime.createView(landID, {')
  lines.push('      playerID: options?.playerID,')
  lines.push('      deviceID: options?.deviceID,')
  lines.push('      metadata: options?.metadata,')
  lines.push('      logger: options?.logger,')
      lines.push('      onStateUpdate: (nextState) => {')
      lines.push('        syncInto(this.state as any, nextState)')
      lines.push('      },')
  lines.push('      onError: (error, context) => {')
  lines.push('        options?.logger?.error(`StateTree view error: ${error.message}`, context)')
  lines.push('      }')
  lines.push('    })')
  lines.push('')

  // actions
  lines.push('    this.actions = {')
  for (const a of actions) {
    lines.push(
      `      ${a.propertyName}: (payload) => this.view.sendAction(${JSON.stringify(
        a.id
      )}, payload) as Promise<any>,`
    )
  }
  lines.push('    } as Actions')
  lines.push('')

  // client events
  lines.push('    this.events = {')
  for (const e of clientEvents) {
    lines.push(
      `      ${e.propertyName}: (payload) => this.view.sendEvent(${JSON.stringify(
        e.id
      )}, payload),`
    )
  }
  lines.push('    } as ClientEvents')
  lines.push('')

  // server events
  lines.push('    this.on = {')
  for (const e of serverEvents) {
    lines.push(
      `      ${e.propertyName}: (handler) => this.view.onServerEvent(${JSON.stringify(
        e.id
      )}, handler),`
    )
  }
  lines.push('    } as ServerEventSubscriptions')
  lines.push('  }')
  lines.push('')

  lines.push('  async join() {')
  lines.push('    return this.view.join()')
  lines.push('  }')
  lines.push('')

  lines.push('  destroy() {')
  lines.push('    this.view.destroy()')
  lines.push('  }')
  lines.push('')

  lines.push('  get landId(): string {')
  lines.push('    return this.view.landId')
  lines.push('  }')
  lines.push('')
  lines.push('  /**')
  lines.push('   * Expose underlying runtime for advanced scenarios.')
  lines.push('   * This also ensures TypeScript treats the runtime field as used.')
  lines.push('   */')
  lines.push('  getRuntime(): StateTreeRuntime {')
  lines.push('    return this.runtime')
  lines.push('  }')
  lines.push('}')
  lines.push('')

  // Simple deep sync helper to keep `state` object identity stable.
  lines.push('function syncInto(target: any, source: any): void {')
  lines.push('  if (source == null || typeof source !== "object") {')
  lines.push('    return')
  lines.push('  }')
  lines.push('')
  lines.push('  for (const key of Object.keys(target)) {')
  lines.push('    if (!(key in source)) {')
  lines.push('      delete target[key]')
  lines.push('    }')
  lines.push('  }')
  lines.push('')
  lines.push('  for (const [key, value] of Object.entries(source)) {')
  lines.push('    const src: any = value')
  lines.push('    const dst: any = target[key]')
  lines.push('')
  lines.push('    if (Array.isArray(src)) {')
  lines.push('      if (!Array.isArray(dst)) {')
  lines.push('        target[key] = src.slice()')
  lines.push('      } else {')
  lines.push('        dst.length = 0')
  lines.push('        for (const item of src) {')
  lines.push('          dst.push(item)')
  lines.push('        }')
  lines.push('      }')
  lines.push('      continue')
  lines.push('    }')
  lines.push('')
  lines.push('    if (src && typeof src === "object") {')
  lines.push('      if (!dst || typeof dst !== "object" || Array.isArray(dst)) {')
  lines.push('        target[key] = {}')
  lines.push('      }')
  lines.push('      syncInto(target[key], src)')
  lines.push('      continue')
  lines.push('    }')
  lines.push('')
  lines.push('    target[key] = src')
  lines.push('  }')
  lines.push('}')
  lines.push('')

  return lines.join('\n')
}

function toPascalCase(input: string): string {
  const parts = input.split(/[^a-zA-Z0-9]+/).filter(Boolean)
  if (parts.length === 0) return ''
  return parts
    .map((part) => part.charAt(0).toUpperCase() + part.slice(1))
    .join('')
}

function toActionPropertyName(payloadType: string, fallbackID: string): string {
  if (payloadType.endsWith('Action')) {
    const base = payloadType.slice(0, -'Action'.length)
    return lowerFirst(base)
  }
  return toCamelFromId(fallbackID)
}

function toEventPropertyName(payloadType: string, fallbackID: string): string {
  if (payloadType.endsWith('Event')) {
    const base = payloadType.slice(0, -'Event'.length)
    return lowerFirst(base)
  }
  return toCamelFromId(fallbackID)
}

function lowerFirst(value: string): string {
  if (!value) return value
  return value.charAt(0).toLowerCase() + value.slice(1)
}

function toCamelFromId(id: string): string {
  const parts = id.split(/[^a-zA-Z0-9]+/).filter(Boolean)
  if (parts.length === 0) return id
  const [first, ...rest] = parts
  return first.toLowerCase() + rest.map((p) => p.charAt(0).toUpperCase() + p.slice(1)).join('')
}

function inferResponseType(payloadType: string, defNames: Set<string>): string | undefined {
  const candidates: string[] = []

  if (payloadType.endsWith('Action')) {
    const base = payloadType.slice(0, -'Action'.length)
    candidates.push(`${base}Response`)
  }

  if (payloadType.endsWith('Request')) {
    const base = payloadType.slice(0, -'Request'.length)
    candidates.push(`${base}Response`)
  }

  for (const candidate of candidates) {
    if (defNames.has(candidate)) {
      return candidate
    }
  }

  return undefined
}

