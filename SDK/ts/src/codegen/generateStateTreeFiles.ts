import { join } from 'node:path'
import type { LandDefinition, ProtocolSchema } from './schema.js'
import { resolveRefName } from './typeMapper.js'
import { writeFileRecursive } from './writeFile.js'
import type { Framework } from './index.js'

interface ActionBinding {
  id: string
  payloadType: string
  propertyName: string
  responseType?: string
}

interface EventBinding {
  id: string
  payloadType: string
  propertyName: string
}

function generateHeader(): string {
  return [
    '// AUTO-GENERATED BY @swiftstatetree/sdk codegen.',
    '// Do not edit this file directly.',
    ''
  ].join('\n')
}

export async function generateStateTreeFiles(
  schema: ProtocolSchema,
  outputDir: string,
  framework?: Framework
): Promise<void> {
  for (const [landID, landDef] of Object.entries(schema.lands)) {
    await generateForLand(schema, landID, landDef, outputDir, framework)
  }
}

async function generateForLand(
  schema: ProtocolSchema,
  landID: string,
  landDef: LandDefinition,
  outputDir: string,
  framework?: Framework
): Promise<void> {
  const landDir = join(outputDir, landID)
  const classBaseName = toPascalCase(landID)
  const className = `${classBaseName}StateTree`

  const actions = collectActionBindings(schema, landDef)
  const clientEvents = collectEventBindings(landDef.clientEvents)
  const serverEvents = collectEventBindings(landDef.events)

  const bindingsSource = generateBindingsTs(schema, landID, landDef, actions, clientEvents, serverEvents)
  const indexSource = generateIndexTs(landID, className, actions, clientEvents, serverEvents)

  await writeFileRecursive(join(landDir, 'bindings.ts'), bindingsSource)
  await writeFileRecursive(join(landDir, 'index.ts'), indexSource)

  // Generate framework-specific helper if requested
  if (framework === 'vue') {
    const composableName = `use${classBaseName}`
    const composableSource = generateVueComposable(
      landID,
      className,
      composableName,
      classBaseName,
      actions,
      clientEvents,
      landDef.stateType
    )
    await writeFileRecursive(join(landDir, `${composableName}.ts`), composableSource)
  }
}

function collectActionBindings(schema: ProtocolSchema, landDef: LandDefinition): ActionBinding[] {
  const result: ActionBinding[] = []
  const actions = landDef.actions ?? {}
  const defNames = new Set(Object.keys(schema.defs))

  for (const [id, ref] of Object.entries(actions)) {
    const payloadType = resolveRefName(ref.$ref)
    const propertyName = toActionPropertyName(payloadType, id)
    const responseType = inferResponseType(payloadType, defNames)
    result.push({ id, payloadType, propertyName, responseType })
  }

  return result
}

function collectEventBindings(events?: Record<string, { $ref: string }>): EventBinding[] {
  const result: EventBinding[] = []
  if (!events) return result

  for (const [id, ref] of Object.entries(events)) {
    const payloadType = resolveRefName(ref.$ref)
    const propertyName = toEventPropertyName(payloadType, id)
    // Use the full type name (e.g., "ClickCookieEvent") as the event ID
    // instead of the short schema ID (e.g., "ClickCookie")
    result.push({ id: payloadType, payloadType, propertyName })
  }

  return result
}

function generateBindingsTs(
  schema: ProtocolSchema,
  landID: string,
  landDef: LandDefinition,
  actions: ActionBinding[],
  clientEvents: EventBinding[],
  serverEvents: EventBinding[]
): string {
  const lines: string[] = []
  lines.push(generateHeader())

  const importTypes = new Set<string>()
  importTypes.add(landDef.stateType)
  for (const a of actions) {
    importTypes.add(a.payloadType)
    if (a.responseType) {
      importTypes.add(a.responseType)
    }
  }
  for (const e of clientEvents) {
    importTypes.add(e.payloadType)
  }
  for (const e of serverEvents) {
    importTypes.add(e.payloadType)
  }

  const sortedImportTypes = [...importTypes].sort()
  if (sortedImportTypes.length > 0) {
    lines.push(`import type { ${sortedImportTypes.join(', ')} } from '../defs'`)
    lines.push('')
  }

  lines.push(`export const LAND_TYPE = ${JSON.stringify(landID)} as const`)
  lines.push('')

  lines.push(`export type LandState = ${landDef.stateType}`)
  lines.push('')

  // Actions
  lines.push('export interface ActionPayloads {')
  for (const a of actions) {
    lines.push(`  ${a.propertyName}: ${a.payloadType}`)
  }
  lines.push('}')
  lines.push('')

  lines.push('export interface ActionResponses {')
  for (const a of actions) {
    const responseType = a.responseType ?? 'any'
    lines.push(`  ${a.propertyName}: ${responseType}`)
  }
  lines.push('}')
  lines.push('')

  lines.push('export type ActionName = keyof ActionPayloads')
  lines.push('')

  // Client events
  lines.push('export interface ClientEventPayloads {')
  for (const e of clientEvents) {
    lines.push(`  ${e.propertyName}: ${e.payloadType}`)
  }
  lines.push('}')
  lines.push('')

  lines.push('export type ClientEventName = keyof ClientEventPayloads')
  lines.push('')

  // Server events
  lines.push('export interface ServerEventPayloads {')
  for (const e of serverEvents) {
    lines.push(`  ${e.propertyName}: ${e.payloadType}`)
  }
  lines.push('}')
  lines.push('')

  lines.push('export type ServerEventName = keyof ServerEventPayloads')
  lines.push('')

  lines.push('export type Actions = {')
  lines.push('  [K in ActionName]: (payload: ActionPayloads[K]) => Promise<ActionResponses[K]>')
  lines.push('}')
  lines.push('')

  lines.push('export type ClientEvents = {')
  lines.push('  [K in ClientEventName]: (payload: ClientEventPayloads[K]) => void')
  lines.push('}')
  lines.push('')

  lines.push('export type ServerEventSubscriptions = {')
  lines.push('  [K in ServerEventName]: (handler: (payload: ServerEventPayloads[K]) => void) => () => void')
  lines.push('}')
  lines.push('')

  return lines.join('\n')
}

function generateIndexTs(
  landID: string,
  className: string,
  actions: ActionBinding[],
  clientEvents: EventBinding[],
  serverEvents: EventBinding[]
): string {
  const lines: string[] = []
  lines.push(generateHeader())

  lines.push(`import type { StateTreeRuntime, Logger } from '@swiftstatetree/sdk/core'`)
  lines.push(`import { StateTreeView } from '@swiftstatetree/sdk/core'`)
  lines.push(
    `import type { LandState, Actions, ClientEvents, ServerEventSubscriptions } from './bindings'`
  )
  lines.push(`import { LAND_TYPE } from './bindings'`)
  lines.push('')

  lines.push('export interface StateTreeOptions {')
  lines.push('  landID?: string')
  lines.push('  playerID?: string')
  lines.push('  deviceID?: string')
  lines.push('  metadata?: Record<string, any>')
  lines.push('  logger?: Logger')
  lines.push('}')
  lines.push('')

  lines.push(`export class ${className} {`)
  lines.push('  readonly landType = LAND_TYPE')
  lines.push('  readonly state: LandState')
  lines.push('  readonly actions: Actions')
  lines.push('  readonly events: ClientEvents')
  lines.push('  readonly on: ServerEventSubscriptions')
  lines.push('')
  lines.push('  private readonly runtime: StateTreeRuntime')
  lines.push('  private readonly view: StateTreeView')
  lines.push('')

  lines.push('  constructor(runtime: StateTreeRuntime, options?: StateTreeOptions) {')
  lines.push('    this.runtime = runtime')
  lines.push('    const landID = options?.landID ?? LAND_TYPE')
  lines.push('    this.state = {} as LandState')
  lines.push('')
  lines.push('    this.view = runtime.createView(landID, {')
  lines.push('      playerID: options?.playerID,')
  lines.push('      deviceID: options?.deviceID,')
  lines.push('      metadata: options?.metadata,')
  lines.push('      logger: options?.logger,')
      lines.push('      onStateUpdate: (nextState) => {')
      lines.push('        syncInto(this.state as any, nextState)')
      lines.push('      },')
  lines.push('      onError: (error, context) => {')
  lines.push('        options?.logger?.error(`StateTree view error: ${error.message}`, context)')
  lines.push('      }')
  lines.push('    })')
  lines.push('')

  // actions
  lines.push('    this.actions = {')
  for (const a of actions) {
    lines.push(
      `      ${a.propertyName}: (payload) => this.view.sendAction(${JSON.stringify(
        a.id
      )}, payload) as Promise<any>,`
    )
  }
  lines.push('    } as Actions')
  lines.push('')

  // client events
  lines.push('    this.events = {')
  for (const e of clientEvents) {
    lines.push(
      `      ${e.propertyName}: (payload) => this.view.sendEvent(${JSON.stringify(
        e.id
      )}, payload),`
    )
  }
  lines.push('    } as ClientEvents')
  lines.push('')

  // server events
  lines.push('    this.on = {')
  for (const e of serverEvents) {
    lines.push(
      `      ${e.propertyName}: (handler) => this.view.onServerEvent(${JSON.stringify(
        e.id
      )}, handler),`
    )
  }
  lines.push('    } as ServerEventSubscriptions')
  lines.push('  }')
  lines.push('')

  lines.push('  async join() {')
  lines.push('    return this.view.join()')
  lines.push('  }')
  lines.push('')

  lines.push('  destroy() {')
  lines.push('    this.view.destroy()')
  lines.push('  }')
  lines.push('')

  lines.push('  get landId(): string {')
  lines.push('    return this.view.landId')
  lines.push('  }')
  lines.push('')
  lines.push('  /**')
  lines.push('   * Expose underlying runtime for advanced scenarios.')
  lines.push('   * This also ensures TypeScript treats the runtime field as used.')
  lines.push('   */')
  lines.push('  getRuntime(): StateTreeRuntime {')
  lines.push('    return this.runtime')
  lines.push('  }')
  lines.push('}')
  lines.push('')

  // Simple deep sync helper to keep `state` object identity stable.
  lines.push('function syncInto(target: any, source: any): void {')
  lines.push('  if (source == null || typeof source !== "object") {')
  lines.push('    return')
  lines.push('  }')
  lines.push('')
  lines.push('  for (const key of Object.keys(target)) {')
  lines.push('    if (!(key in source)) {')
  lines.push('      delete target[key]')
  lines.push('    }')
  lines.push('  }')
  lines.push('')
  lines.push('  for (const [key, value] of Object.entries(source)) {')
  lines.push('    const src: any = value')
  lines.push('    const dst: any = target[key]')
  lines.push('')
  lines.push('    if (Array.isArray(src)) {')
  lines.push('      if (!Array.isArray(dst)) {')
  lines.push('        target[key] = src.slice()')
  lines.push('      } else {')
  lines.push('        dst.length = 0')
  lines.push('        for (const item of src) {')
  lines.push('          dst.push(item)')
  lines.push('        }')
  lines.push('      }')
  lines.push('      continue')
  lines.push('    }')
  lines.push('')
  lines.push('    if (src && typeof src === "object") {')
  lines.push('      if (!dst || typeof dst !== "object" || Array.isArray(dst)) {')
  lines.push('        target[key] = {}')
  lines.push('      }')
  lines.push('      syncInto(target[key], src)')
  lines.push('      continue')
  lines.push('    }')
  lines.push('')
  lines.push('    target[key] = src')
  lines.push('  }')
  lines.push('}')
  lines.push('')

  return lines.join('\n')
}

function toPascalCase(input: string): string {
  const parts = input.split(/[^a-zA-Z0-9]+/).filter(Boolean)
  if (parts.length === 0) return ''
  return parts
    .map((part) => part.charAt(0).toUpperCase() + part.slice(1))
    .join('')
}

function toActionPropertyName(payloadType: string, fallbackID: string): string {
  if (payloadType.endsWith('Action')) {
    const base = payloadType.slice(0, -'Action'.length)
    return lowerFirst(base)
  }
  return toCamelFromId(fallbackID)
}

function toEventPropertyName(payloadType: string, fallbackID: string): string {
  if (payloadType.endsWith('Event')) {
    const base = payloadType.slice(0, -'Event'.length)
    return lowerFirst(base)
  }
  return toCamelFromId(fallbackID)
}

function lowerFirst(value: string): string {
  if (!value) return value
  return value.charAt(0).toLowerCase() + value.slice(1)
}

function toCamelFromId(id: string): string {
  const parts = id.split(/[^a-zA-Z0-9]+/).filter(Boolean)
  if (parts.length === 0) return id
  const [first, ...rest] = parts
  return first.toLowerCase() + rest.map((p) => p.charAt(0).toUpperCase() + p.slice(1)).join('')
}

function generateVueComposable(
  landID: string,
  className: string,
  composableName: string,
  classBaseName: string,
  actions: ActionBinding[],
  clientEvents: EventBinding[],
  stateType: string
): string {
  const lines: string[] = []
  lines.push(generateHeader())

  lines.push("import { ref, reactive, computed } from 'vue'")
  lines.push("import type { Ref, ComputedRef } from 'vue'")
  lines.push("import { StateTreeRuntime } from '@swiftstatetree/sdk/core'")
  lines.push(`import { ${className} } from './index.js'`)
  lines.push(`import type { ${stateType} } from '../defs.js'`)
  
  // Import action and event payload types, and response types
  const payloadTypes = new Set<string>()
  const responseTypes = new Set<string>()
  for (const action of actions) {
    payloadTypes.add(action.payloadType)
    if (action.responseType) {
      responseTypes.add(action.responseType)
    }
  }
  for (const event of clientEvents) {
    payloadTypes.add(event.payloadType)
  }
  const allTypes = new Set([...payloadTypes, ...responseTypes])
  if (allTypes.size > 0) {
    const sortedTypes = [...allTypes].sort()
    lines.push(`import type { ${sortedTypes.join(', ')} } from '../defs.js'`)
  }
  lines.push('')

  lines.push('interface ConnectOptions {')
  lines.push('  wsUrl: string')
  lines.push('  playerName?: string')
  lines.push('  playerID?: string')
  lines.push('  deviceID?: string')
  lines.push('  metadata?: Record<string, any>')
  lines.push('}')
  lines.push('')

  // Module-level state (singleton pattern)
  lines.push('const runtime = ref<StateTreeRuntime | null>(null)')
  lines.push(`const tree = ref<${className} | null>(null)`)
  lines.push('')
  lines.push(`const state: Ref<${stateType} | null> = ref<${stateType} | null>(null)`)
  lines.push('const currentPlayerID = ref<string | null>(null)')
  lines.push('')
  lines.push('const isConnecting = ref(false)')
  lines.push('const isConnected = ref(false)')
  lines.push('const isJoined = ref(false)')
  lines.push('const lastError = ref<string | null>(null)')
  lines.push('')

  // Generate return type interface
  const returnTypeName = `${classBaseName}ComposableReturn`
  lines.push(`export interface ${returnTypeName} {`)
  lines.push(`  state: Ref<${stateType} | null>`)
  lines.push('  currentPlayerID: Ref<string | null>')
  lines.push('  isConnecting: Ref<boolean>')
  lines.push('  isConnected: Ref<boolean>')
  lines.push('  isJoined: Ref<boolean>')
  lines.push('  lastError: Ref<string | null>')
  lines.push('  connect: (opts: ConnectOptions) => Promise<void>')
  lines.push('  disconnect: () => Promise<void>')
  
  // Add action methods
  for (const action of actions) {
    const actionName = action.propertyName
    const payloadType = action.payloadType
    const responseType = action.responseType ?? 'any'
    lines.push(`  ${actionName}: (payload: ${payloadType}) => Promise<${responseType}>`)
  }
  
  // Add event methods
  for (const event of clientEvents) {
    const eventName = event.propertyName
    const payloadType = event.payloadType
    lines.push(`  ${eventName}: (payload: ${payloadType}) => Promise<void>`)
  }
  
  lines.push(`  tree: ComputedRef<${className} | null>`)
  lines.push('}')
  lines.push('')
  
  lines.push(`export function ${composableName}(): ${returnTypeName} {`)
  lines.push('')
  lines.push('  async function connect(opts: ConnectOptions): Promise<void> {')
  lines.push('    if (isConnecting.value || isConnected.value) return')
  lines.push('')
  lines.push('    isConnecting.value = true')
  lines.push('    lastError.value = null')
  lines.push('')
  lines.push('    try {')
  lines.push('      const r = new StateTreeRuntime()')
  lines.push('      await r.connect(opts.wsUrl)')
  lines.push('      runtime.value = r')
  lines.push('      isConnected.value = true')
  lines.push('')
  lines.push('      const metadata: Record<string, any> = opts.metadata ?? {}')
  lines.push('      if (opts.playerName && opts.playerName.trim().length > 0) {')
  lines.push('        metadata.username = opts.playerName.trim()')
  lines.push('      }')
  lines.push('')
  lines.push(`      const t = new ${className}(r, {`)
  lines.push('        playerID: opts.playerID,')
  lines.push('        deviceID: opts.deviceID,')
  lines.push('        metadata,')
  lines.push('        logger: {')
  lines.push('          debug: () => {},')
  lines.push('          info: (msg) => console.log(`[StateTree]`, msg),')
  lines.push('          warn: (msg) => console.warn(`[StateTree]`, msg),')
  lines.push('          error: (msg) => console.error(`[StateTree]`, msg)')
  lines.push('        }')
  lines.push('      })')
  lines.push('      tree.value = t')
  lines.push('')
  lines.push('      const joinResult = await t.join()')
  lines.push('      if (!joinResult.success) {')
  lines.push('        throw new Error(joinResult.reason ?? \'Join failed\')')
  lines.push('      }')
  lines.push('')
  lines.push('      currentPlayerID.value = joinResult.playerID ?? null')
  lines.push('      ')
  lines.push('      // Make t.state reactive so Vue can track changes directly')
  lines.push('      // This allows direct access like state.players[playerID].cookies in templates')
  lines.push(`      const reactiveState = reactive(t.state as ${stateType})`)
  lines.push('      state.value = reactiveState')
  lines.push('      ')
  lines.push('      // Override t.state to point to reactiveState so syncInto updates it directly')
  lines.push('      // This way syncInto will update the reactive object and Vue tracks it automatically')
  lines.push('      Object.defineProperty(t, \'state\', {')
  lines.push('        get: () => reactiveState,')
  lines.push('        enumerable: true,')
  lines.push('        configurable: true')
  lines.push('      })')
  lines.push('      ')
  lines.push('      isJoined.value = true')
  lines.push('    } catch (error) {')
  lines.push('      const message = (error as Error).message ?? String(error)')
  lines.push('      lastError.value = message')
  lines.push('      console.error(\'Connect/join failed:\', error)')
  lines.push('      await disconnect()')
  lines.push('    } finally {')
  lines.push('      isConnecting.value = false')
  lines.push('    }')
  lines.push('  }')
  lines.push('')
  lines.push('  async function disconnect(): Promise<void> {')
  lines.push('    if (tree.value) {')
  lines.push('      tree.value.destroy()')
  lines.push('    }')
  lines.push('    if (runtime.value && \'disconnect\' in runtime.value && typeof runtime.value.disconnect === \'function\') {')
  lines.push('      runtime.value.disconnect()')
  lines.push('    }')
  lines.push('    runtime.value = null')
  lines.push('    tree.value = null')
  lines.push('    state.value = null')
  lines.push('    currentPlayerID.value = null')
  lines.push('    isConnected.value = false')
  lines.push('    isJoined.value = false')
  lines.push('  }')
  lines.push('')

  // Generate action wrappers
  for (const action of actions) {
    const actionName = action.propertyName
    const payloadType = action.payloadType
    const responseType = action.responseType ?? 'any'
    lines.push(`  async function ${actionName}(payload: ${payloadType}): Promise<${responseType}> {`)
    lines.push('    if (!tree.value || !isJoined.value) {')
    lines.push(`      throw new Error('Not connected or not joined')`)
    lines.push('    }')
    lines.push('    try {')
    lines.push(`      const res = await tree.value.actions.${actionName}(payload)`)
    lines.push('      lastError.value = null')
    lines.push('      return res')
    lines.push('    } catch (error) {')
    lines.push(`      console.error('${actionName} failed:', error)`)
    lines.push('      lastError.value = (error as Error).message ?? String(error)')
    lines.push('      throw error')
    lines.push('    }')
    lines.push('  }')
    lines.push('')
  }

  // Generate event wrappers
  for (const event of clientEvents) {
    const eventName = event.propertyName
    const payloadType = event.payloadType
    lines.push(`  async function ${eventName}(payload: ${payloadType}): Promise<void> {`)
    lines.push('    if (!tree.value || !isJoined.value) return')
    lines.push('    try {')
    lines.push(`      await tree.value.events.${eventName}(payload)`)
    lines.push('      lastError.value = null')
    lines.push('    } catch (error) {')
    lines.push(`      console.error('${eventName} failed:', error)`)
    lines.push('      lastError.value = (error as Error).message ?? String(error)')
    lines.push('    }')
    lines.push('  }')
    lines.push('')
  }

  // Return object
  lines.push('  return {')
  lines.push('    state,')
  lines.push('    currentPlayerID,')
  lines.push('    isConnecting,')
  lines.push('    isConnected,')
  lines.push('    isJoined,')
  lines.push('    lastError,')
  lines.push('    connect,')
  lines.push('    disconnect,')

  // Add action methods
  for (const action of actions) {
    lines.push(`    ${action.propertyName},`)
  }

  // Add event methods
  for (const event of clientEvents) {
    lines.push(`    ${event.propertyName},`)
  }

  // Also expose tree for advanced usage
  lines.push('    // Advanced: access to underlying tree instance')
  lines.push(`    tree: computed(() => tree.value) as ComputedRef<${className} | null>`)
  lines.push('  }')
  lines.push('}')
  lines.push('')

  return lines.join('\n')
}

function inferResponseType(payloadType: string, defNames: Set<string>): string | undefined {
  const candidates: string[] = []

  if (payloadType.endsWith('Action')) {
    const base = payloadType.slice(0, -'Action'.length)
    candidates.push(`${base}Response`)
  }

  if (payloadType.endsWith('Request')) {
    const base = payloadType.slice(0, -'Request'.length)
    candidates.push(`${base}Response`)
  }

  for (const candidate of candidates) {
    if (defNames.has(candidate)) {
      return candidate
    }
  }

  return undefined
}

