// AUTO-GENERATED BY @swiftstatetree/sdk codegen.
// Do not edit this file directly.

import type { StateTreeRuntime, Logger, StatePatch, MapSubscriptions } from '@swiftstatetree/sdk/core'
import { StateTreeView } from '@swiftstatetree/sdk/core'
import type { LandState, Actions, ClientEvents, ServerEventSubscriptions } from './bindings'
import { LAND_TYPE } from './bindings'
import { SCHEMA } from '../schema.js'
import type { Acceleration2, Position2, Velocity2 } from '../defs'

// Re-export MapSubscriptions interface from SDK core
export type { MapSubscriptions } from '@swiftstatetree/sdk/core'

export interface StateTreeOptions {
  landID?: string
  playerID?: string
  deviceID?: string
  metadata?: Record<string, any>
  logger?: Logger
}

export class DeterministicMathDemoStateTree {
  readonly landType = LAND_TYPE
  readonly state: LandState
  readonly actions: Actions
  readonly events: ClientEvents
  readonly on: ServerEventSubscriptions

  /** Type-safe subscriptions for playerAccelerations map */
  readonly playerAccelerations: MapSubscriptions<Acceleration2>
  /** Type-safe subscriptions for playerPositions map */
  readonly playerPositions: MapSubscriptions<Position2>
  /** Type-safe subscriptions for playerVelocities map */
  readonly playerVelocities: MapSubscriptions<Velocity2>

  private readonly runtime: StateTreeRuntime
  private readonly view: StateTreeView

  constructor(runtime: StateTreeRuntime, options?: StateTreeOptions) {
    this.runtime = runtime
    const landID = options?.landID ?? LAND_TYPE
    this.state = {} as LandState

    this.view = runtime.createView(landID, {
      schema: SCHEMA,  // Pass schema for accurate type checking
      playerID: options?.playerID,
      deviceID: options?.deviceID,
      metadata: options?.metadata,
      logger: options?.logger,
      onStateUpdate: (nextState) => {
        syncInto(this.state as any, nextState)
      },
      onError: (error, context) => {
        options?.logger?.error(`StateTree view error: ${error.message}`, context)
      }
    })

    this.actions = {
    } as Actions

    this.events = {
    } as ClientEvents

    this.on = {
    } as ServerEventSubscriptions

    // Initialize playerAccelerations map subscriptions using SDK core
    this.playerAccelerations = this.view.createMapSubscriptions<Acceleration2>(
      '/playerAccelerations',
      (state) => state?.playerAccelerations as Record<string, Acceleration2> | undefined
    )
    // Initialize playerPositions map subscriptions using SDK core
    this.playerPositions = this.view.createMapSubscriptions<Position2>(
      '/playerPositions',
      (state) => state?.playerPositions as Record<string, Position2> | undefined
    )
    // Initialize playerVelocities map subscriptions using SDK core
    this.playerVelocities = this.view.createMapSubscriptions<Velocity2>(
      '/playerVelocities',
      (state) => state?.playerVelocities as Record<string, Velocity2> | undefined
    )
  }

  async join() {
    return this.view.join()
  }

  destroy() {
    this.view.destroy()
  }

  get landId(): string {
    return this.view.landId
  }

  /**
   * Get the current player ID (set after successful join)
   */
  get currentPlayerID(): string | undefined {
    return this.view.currentPlayerID
  }

  /**
   * Expose underlying runtime for advanced scenarios.
   * This also ensures TypeScript treats the runtime field as used.
   */
  getRuntime(): StateTreeRuntime {
    return this.runtime
  }

  /**
   * Subscribe to patch operations.
   * Useful for tracking add/remove/replace operations on specific paths.
   * @param callback - Called for each patch with the patch info and decoded value
   * @returns Unsubscribe function
   */
  onPatch(callback: (patch: StatePatch, decodedValue?: any) => void): () => void {
    return this.view.onPatch(callback)
  }
}

function isPlainObject(value: any): value is Record<string, any> {
  if (!value || typeof value !== "object") {
    return false
  }
  const proto = Object.getPrototypeOf(value)
  return proto === Object.prototype || proto === null
}

function syncInto(target: any, source: any): void {
  if (source == null || typeof source !== "object") {
    return
  }

  for (const key of Object.keys(target)) {
    if (!(key in source)) {
      delete target[key]
    }
  }

  for (const [key, value] of Object.entries(source)) {
    const src: any = value
    const dst: any = target[key]

    if (Array.isArray(src)) {
      if (!Array.isArray(dst)) {
        target[key] = src.slice()
      } else {
        dst.length = 0
        for (const item of src) {
          dst.push(item)
        }
      }
      continue
    }

    if (src && typeof src === "object") {
      if (!isPlainObject(src)) {
        target[key] = src
        continue
      }
      if (!dst || typeof dst !== "object" || Array.isArray(dst) || !isPlainObject(dst)) {
        target[key] = {}
      }
      syncInto(target[key], src)
      continue
    }

    target[key] = src
  }
}
