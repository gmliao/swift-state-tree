// AUTO-GENERATED BY @swiftstatetree/sdk codegen.
// Do not edit this file directly.

import type { StateTreeRuntime, Logger, StatePatch, MapSubscriptions } from '@swiftstatetree/sdk/core'
import { StateTreeView } from '@swiftstatetree/sdk/core'
import type { LandState, Actions, ClientEvents, ServerEventSubscriptions, EventSubscription, EventHandler } from './bindings'
import { LAND_TYPE } from './bindings'
import { SCHEMA } from '../schema.js'
import type { CookiePlayerPublicState, CookiePlayerPrivateState } from '../defs'
import type { BuyUpgradeAction, BuyUpgradeResponse, ClickCookieEvent } from '../defs'

// Re-export MapSubscriptions interface from SDK core
export type { MapSubscriptions } from '@swiftstatetree/sdk/core'

export interface StateTreeOptions {
  landID?: string
  playerID?: string
  deviceID?: string
  metadata?: Record<string, any>
  logger?: Logger
}

export class CookieStateTree {
  readonly landType = LAND_TYPE
  readonly state: LandState
  readonly actions: Actions
  readonly events: ClientEvents
  readonly on: ServerEventSubscriptions

  /** Type-safe subscriptions for players map */
  readonly players: MapSubscriptions<CookiePlayerPublicState>
  /** Type-safe subscriptions for privateStates map */
  readonly privateStates: MapSubscriptions<CookiePlayerPrivateState>

  /** Type-safe method for buyUpgrade action */
  readonly buyUpgrade: (payload: BuyUpgradeAction) => Promise<BuyUpgradeResponse>

  /** Type-safe method for clickCookie client event */
  readonly clickCookie: (payload: ClickCookieEvent) => void

  private readonly runtime: StateTreeRuntime
  private readonly view: StateTreeView

  constructor(runtime: StateTreeRuntime, options?: StateTreeOptions) {
    this.runtime = runtime
    const landID = options?.landID ?? LAND_TYPE
    this.state = {} as LandState

    this.view = runtime.createView(landID, {
      schema: SCHEMA,  // Pass schema for accurate type checking
      playerID: options?.playerID,
      deviceID: options?.deviceID,
      metadata: options?.metadata,
      logger: options?.logger,
      onStateUpdate: (nextState) => {
        syncInto(this.state as any, nextState)
      },
      onError: (error, context) => {
        options?.logger?.error(`StateTree view error: ${error.message}`, context)
      }
    })

    this.buyUpgrade = (payload: BuyUpgradeAction) => {
      return this.view.sendAction("BuyUpgrade", payload) as Promise<BuyUpgradeResponse>
    }

    this.actions = {
      buyUpgrade: this.buyUpgrade,
    } as Actions

    this.clickCookie = (payload: ClickCookieEvent) => {
      this.view.sendEvent("ClickCookie", payload)
    }

    this.events = {
      clickCookie: this.clickCookie,
    } as ClientEvents

    this.on = {
    } as ServerEventSubscriptions

    // Initialize players map subscriptions using SDK core
    this.players = this.view.createMapSubscriptions<CookiePlayerPublicState>(
      '/players',
      (state) => state?.players as Record<string, CookiePlayerPublicState> | undefined
    )
    // Initialize privateStates map subscriptions using SDK core
    this.privateStates = this.view.createMapSubscriptions<CookiePlayerPrivateState>(
      '/privateStates',
      (state) => state?.privateStates as Record<string, CookiePlayerPrivateState> | undefined
    )
  }

  async join() {
    return this.view.join()
  }

  destroy() {
    this.view.destroy()
  }

  get landId(): string {
    return this.view.landId
  }

  /**
   * Get the current player ID (set after successful join)
   */
  get currentPlayerID(): string | undefined {
    return this.view.currentPlayerID
  }

  /**
   * Expose underlying runtime for advanced scenarios.
   * This also ensures TypeScript treats the runtime field as used.
   */
  getRuntime(): StateTreeRuntime {
    return this.runtime
  }

  /**
   * Subscribe to patch operations.
   * Useful for tracking add/remove/replace operations on specific paths.
   * @param callback - Called for each patch with the patch info and decoded value
   * @returns Unsubscribe function
   */
  onPatch(callback: (patch: StatePatch, decodedValue?: any) => void): () => void {
    return this.view.onPatch(callback)
  }
}

function isPlainObject(value: any): value is Record<string, any> {
  if (!value || typeof value !== "object") {
    return false
  }
  const proto = Object.getPrototypeOf(value)
  return proto === Object.prototype || proto === null
}

function syncInto(target: any, source: any): void {
  if (source == null || typeof source !== "object") {
    return
  }

  for (const key of Object.keys(target)) {
    if (!(key in source)) {
      delete target[key]
    }
  }

  for (const [key, value] of Object.entries(source)) {
    const src: any = value
    const dst: any = target[key]

    if (Array.isArray(src)) {
      if (!Array.isArray(dst)) {
        target[key] = src.slice()
      } else {
        dst.length = 0
        for (const item of src) {
          dst.push(item)
        }
      }
      continue
    }

    if (src && typeof src === "object") {
      if (!isPlainObject(src)) {
        target[key] = src
        continue
      }
      if (!dst || typeof dst !== "object" || Array.isArray(dst) || !isPlainObject(dst)) {
        target[key] = {}
      }
      syncInto(target[key], src)
      continue
    }

    target[key] = src
  }
}
