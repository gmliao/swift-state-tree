import Phaser from 'phaser'
import { PlayerSprite } from '../sprites/PlayerSprite'
import type { PlayerState } from '../generated/defs'
import type { HeroDefenseStateTree } from '../generated/hero-defense'
import type { Unsubscribe } from '../generated/hero-defense/bindings'

export interface PlayerManagerConfig {
  /** Throttle interval for state logging in ms (default: 1000) */
  logThrottleMs?: number
}

export interface PlayersState {
  [playerID: string]: PlayerState
}

/**
 * Manages all player sprites - creation, updates, and removal.
 * Uses type-safe tree.players.onAdd/onRemove API for detecting player changes.
 */
export class PlayerManager {
  private readonly scene: Phaser.Scene
  private readonly config: Required<PlayerManagerConfig>
  private readonly players: Map<string, PlayerSprite> = new Map()
  private currentPlayer: PlayerSprite | null = null
  private currentPlayerID: string | null = null
  private lastStateLogTime: number = 0
  private onCurrentPlayerUpdate: ((player: PlayerSprite, serverPos: { x: number; y: number }) => void) | null = null
  private unsubscribeAdd: Unsubscribe | null = null
  private unsubscribeRemove: Unsubscribe | null = null

  constructor(scene: Phaser.Scene, config: PlayerManagerConfig = {}) {
    this.scene = scene
    this.config = {
      logThrottleMs: config.logThrottleMs ?? 1000,
    }
  }

  /**
   * Subscribe to a StateTree for player add/remove events.
   * Uses the type-safe tree.players API generated by codegen.
   * Automatically uses tree.currentPlayerID if available.
   * 
   * @param tree - The HeroDefenseStateTree to subscribe to
   * @param currentPlayerID - Optional override for current player ID (defaults to tree.currentPlayerID)
   */
  subscribeToTree(tree: HeroDefenseStateTree, currentPlayerID?: string | null): this {
    // Use provided currentPlayerID, or fallback to tree.currentPlayerID, or keep existing
    if (currentPlayerID !== undefined) {
      this.currentPlayerID = currentPlayerID
    } else if (tree.currentPlayerID) {
      this.currentPlayerID = tree.currentPlayerID
    }

    // Unsubscribe from previous subscriptions
    this.unsubscribeAdd?.()
    this.unsubscribeRemove?.()

    // Type-safe subscription to player additions
    this.unsubscribeAdd = tree.players.onAdd((playerID: string, playerState: PlayerState) => {
      this.handlePlayerAdded(playerID, playerState)
    })

    // Type-safe subscription to player removals
    this.unsubscribeRemove = tree.players.onRemove((playerID: string) => {
      this.handlePlayerRemoved(playerID)
    })

    // Handle existing players that were already in the state before subscription
    // This is important because the initial snapshot may contain players that
    // won't trigger onAdd events (they were added before we subscribed)
    const existingPlayers = tree.state?.players
    if (existingPlayers) {
      for (const [playerID, playerState] of Object.entries(existingPlayers)) {
        if (!this.players.has(playerID)) {
          this.handlePlayerAdded(playerID, playerState)
        }
      }
    }

    return this
  }

  /**
   * Handle player added event
   */
  private handlePlayerAdded(playerID: string, playerState: PlayerState): void {
    // Check if player already exists (shouldn't happen, but be safe)
    if (this.players.has(playerID)) {
      console.warn(`Player ${playerID} already exists, skipping add`)
      return
    }

    const isCurrentPlayer = this.currentPlayerID !== null && 
      String(playerID) === String(this.currentPlayerID)

    // Create new player sprite
    const player = new PlayerSprite(this.scene, playerID, isCurrentPlayer)
    player.setInitialPosition(playerState)
    this.players.set(playerID, player)

    console.log(`ðŸŽ® Player added: ${playerID}`)

    // If this is the current player, track it
    if (isCurrentPlayer) {
      this.currentPlayer = player
      const serverPos = player.getServerPosition(playerState)
      if (this.onCurrentPlayerUpdate) {
        this.onCurrentPlayerUpdate(player, serverPos)
      }
    }
  }

  /**
   * Handle player removed event
   */
  private handlePlayerRemoved(playerID: string): void {
    const player = this.players.get(playerID)
    if (!player) {
      console.warn(`Player ${playerID} not found for removal`)
      return
    }

    player.destroy()
    this.players.delete(playerID)

    console.log(`ðŸŽ® Player removed: ${playerID}`)

    if (playerID === this.currentPlayerID) {
      this.currentPlayer = null
    }
  }

  /**
   * Set the current player ID
   */
  setCurrentPlayerID(playerID: string | null): this {
    this.currentPlayerID = playerID
    return this
  }

  /**
   * Set callback when current player is updated
   */
  onCurrentPlayerUpdated(
    callback: (player: PlayerSprite, serverPos: { x: number; y: number }) => void
  ): this {
    this.onCurrentPlayerUpdate = callback
    return this
  }

  /**
   * Update all players from server state.
   * This is called every frame to update positions/rotations.
   * Player add/remove is handled by tree.players subscriptions (SDK handles late-join).
   */
  update(playersState: PlayersState): PlayerSprite | null {
    // Reset current player tracking
    this.currentPlayer = null

    // Log state update (throttled)
    this.logStateUpdate(playersState)

    // Update existing players and check for new ones
    for (const [playerID, playerState] of Object.entries(playersState)) {
      const player = this.players.get(playerID)
      const isCurrentPlayer = this.currentPlayerID !== null && 
        String(playerID) === String(this.currentPlayerID)

      if (player) {
        // Update player sprite (handles lerp internally)
        player.update(playerState)

        // Track current player
        if (isCurrentPlayer) {
          this.currentPlayer = player
          const serverPos = player.getServerPosition(playerState)
          
          if (this.onCurrentPlayerUpdate) {
            this.onCurrentPlayerUpdate(player, serverPos)
          }
        }
      }
      // Note: Player creation is handled by tree.players.onAdd (SDK handles late-join scenarios)
    }

    return this.currentPlayer
  }

  /**
   * Get the current player sprite
   */
  getCurrentPlayer(): PlayerSprite | null {
    return this.currentPlayer
  }

  /**
   * Get a player sprite by ID
   */
  getPlayer(playerID: string): PlayerSprite | undefined {
    return this.players.get(playerID)
  }

  /**
   * Get all player sprites
   */
  getAllPlayers(): Map<string, PlayerSprite> {
    return this.players
  }

  /**
   * Get player count
   */
  getPlayerCount(): number {
    return this.players.size
  }

  /**
   * Destroy all player sprites and unsubscribe from events
   */
  destroy(): void {
    this.unsubscribeAdd?.()
    this.unsubscribeRemove?.()
    this.unsubscribeAdd = null
    this.unsubscribeRemove = null

    for (const player of this.players.values()) {
      player.destroy()
    }
    this.players.clear()
    this.currentPlayer = null
  }

  private logStateUpdate(playersState: PlayersState): void {
    const now = Date.now()
    if (!this.lastStateLogTime || now - this.lastStateLogTime > this.config.logThrottleMs) {
      const playerCount = Object.keys(playersState).length
      const movingCount = Object.values(playersState).filter(p => p.targetPosition != null).length
      console.log(`ðŸ“¥ Client: State update received - ${playerCount} players, ${movingCount} moving`)
      this.lastStateLogTime = now
    }
  }
}
