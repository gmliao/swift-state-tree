// AUTO-GENERATED BY @swiftstatetree/sdk codegen.
// Do not edit this file directly.

import { ref, reactive, computed } from 'vue'
import type { Ref, ComputedRef } from 'vue'
import { StateTreeRuntime } from '@swiftstatetree/sdk/core'
import { HeroDefenseStateTree } from './index.js'
import { LAND_TYPE } from './bindings.js'
import type { HeroDefenseState } from '../defs.js'
import type { MoveToEvent, PlaceTurretEvent, PlayAction, PlayResponse, ShootEvent, UpdateRotationEvent, UpgradeTurretEvent, UpgradeWeaponEvent } from '../defs.js'

interface ConnectOptions {
  wsUrl: string
  playerName?: string
  playerID?: string
  deviceID?: string
  landID?: string  // Optional: specify room ID (format: "landType:instanceId" or just "instanceId")
  metadata?: Record<string, any>
}

const runtime = ref<StateTreeRuntime | null>(null)
const tree = ref<HeroDefenseStateTree | null>(null)

const state = ref<HeroDefenseState | null>(null) as Ref<HeroDefenseState | null>
const currentPlayerID = ref<string | null>(null)

const isConnecting = ref(false)
const isConnected = ref(false)
const isJoined = ref(false)
const lastError = ref<string | null>(null)

export interface HeroDefenseComposableReturn {
  state: Ref<HeroDefenseState | null>
  currentPlayerID: Ref<string | null>
  isConnecting: Ref<boolean>
  isConnected: Ref<boolean>
  isJoined: Ref<boolean>
  lastError: Ref<string | null>
  connect: (opts: ConnectOptions) => Promise<void>
  disconnect: () => Promise<void>
  play: (payload: PlayAction) => Promise<PlayResponse>
  moveTo: (payload: MoveToEvent) => Promise<void>
  placeTurret: (payload: PlaceTurretEvent) => Promise<void>
  shoot: (payload: ShootEvent) => Promise<void>
  updateRotation: (payload: UpdateRotationEvent) => Promise<void>
  upgradeTurret: (payload: UpgradeTurretEvent) => Promise<void>
  upgradeWeapon: (payload: UpgradeWeaponEvent) => Promise<void>
  tree: ComputedRef<HeroDefenseStateTree | null>
}

export function useHeroDefense(): HeroDefenseComposableReturn {

  async function connect(opts: ConnectOptions): Promise<void> {
    if (isConnecting.value || isConnected.value) return

    isConnecting.value = true
    lastError.value = null

    try {
      const r = new StateTreeRuntime()
      await r.connect(opts.wsUrl)
      runtime.value = r
      isConnected.value = true

      const metadata: Record<string, any> = opts.metadata ?? {}
      if (opts.playerName && opts.playerName.trim().length > 0) {
        metadata.username = opts.playerName.trim()
      }

      // Build landID: if provided, use as-is; if it's just instanceId (no colon), prepend landType
      let landID: string | undefined = opts.landID
      if (landID && !landID.includes(':')) {
        // If only instanceId provided (e.g., "room-123"), prepend landType
        landID = `${LAND_TYPE}:${landID}`
      }

      const t = new HeroDefenseStateTree(r, {
        landID: landID,
        playerID: opts.playerID,
        deviceID: opts.deviceID,
        metadata,
        logger: {
          debug: () => {},
          info: (msg) => console.log(`[StateTree]`, msg),
          warn: (msg) => console.warn(`[StateTree]`, msg),
          error: (msg) => console.error(`[StateTree]`, msg)
        }
      })
      tree.value = t

      const joinResult = await t.join()
      if (!joinResult.success) {
        throw new Error(joinResult.reason ?? 'Join failed')
      }

      currentPlayerID.value = joinResult.playerID ?? null
      
      // Make t.state reactive so Vue can track changes directly
      // This allows direct access like state.players[playerID].cookies in templates
      // Note: SDK automatically converts DeterministicMath types (IVec2, Position2, etc.)
      // from fixed-point integers to class instances, but TypeScript may not infer this correctly
      // after reactive() wrapping, so we use type assertion
      const reactiveState = reactive(t.state as any) as HeroDefenseState
      state.value = reactiveState
      
      // Override t.state to point to reactiveState so syncInto updates it directly
      // This way syncInto will update the reactive object and Vue tracks it automatically
      Object.defineProperty(t, 'state', {
        get: () => reactiveState,
        enumerable: true,
        configurable: true
      })
      
      // Set up disconnect callback for automatic cleanup
      r.onDisconnect(() => {
        if (isConnected.value || isJoined.value) {
          console.warn('⚠️ WebSocket disconnected, cleaning up...')
          // Update state immediately so watchers can react
          isConnected.value = false
          // disconnect() will set isJoined.value = false, triggering watchers
          disconnect()
        }
      })
      
      isJoined.value = true
    } catch (error) {
      const message = (error as Error).message ?? String(error)
      lastError.value = message
      console.error('Connect/join failed:', error)
      await disconnect()
    } finally {
      isConnecting.value = false
    }
  }

  async function disconnect(): Promise<void> {
    if (tree.value) {
      tree.value.destroy()
    }
    if (runtime.value && 'disconnect' in runtime.value && typeof runtime.value.disconnect === 'function') {
      runtime.value.disconnect()
    }
    runtime.value = null
    tree.value = null
    state.value = null
    currentPlayerID.value = null
    isConnected.value = false
    isJoined.value = false
  }

  async function play(payload: PlayAction): Promise<PlayResponse> {
    if (!tree.value || !isJoined.value) {
      throw new Error('Not connected or not joined')
    }
    try {
      const res = await tree.value.actions.play(payload)
      lastError.value = null
      return res
    } catch (error) {
      console.error('play failed:', error)
      lastError.value = (error as Error).message ?? String(error)
      throw error
    }
  }

  async function moveTo(payload: MoveToEvent): Promise<void> {
    if (!tree.value || !isJoined.value) return
    try {
      await tree.value.events.moveTo(payload)
      lastError.value = null
    } catch (error) {
      console.error('moveTo failed:', error)
      lastError.value = (error as Error).message ?? String(error)
    }
  }

  async function placeTurret(payload: PlaceTurretEvent): Promise<void> {
    if (!tree.value || !isJoined.value) return
    try {
      await tree.value.events.placeTurret(payload)
      lastError.value = null
    } catch (error) {
      console.error('placeTurret failed:', error)
      lastError.value = (error as Error).message ?? String(error)
    }
  }

  async function shoot(payload: ShootEvent): Promise<void> {
    if (!tree.value || !isJoined.value) return
    try {
      await tree.value.events.shoot(payload)
      lastError.value = null
    } catch (error) {
      console.error('shoot failed:', error)
      lastError.value = (error as Error).message ?? String(error)
    }
  }

  async function updateRotation(payload: UpdateRotationEvent): Promise<void> {
    if (!tree.value || !isJoined.value) return
    try {
      await tree.value.events.updateRotation(payload)
      lastError.value = null
    } catch (error) {
      console.error('updateRotation failed:', error)
      lastError.value = (error as Error).message ?? String(error)
    }
  }

  async function upgradeTurret(payload: UpgradeTurretEvent): Promise<void> {
    if (!tree.value || !isJoined.value) return
    try {
      await tree.value.events.upgradeTurret(payload)
      lastError.value = null
    } catch (error) {
      console.error('upgradeTurret failed:', error)
      lastError.value = (error as Error).message ?? String(error)
    }
  }

  async function upgradeWeapon(payload: UpgradeWeaponEvent): Promise<void> {
    if (!tree.value || !isJoined.value) return
    try {
      await tree.value.events.upgradeWeapon(payload)
      lastError.value = null
    } catch (error) {
      console.error('upgradeWeapon failed:', error)
      lastError.value = (error as Error).message ?? String(error)
    }
  }

  return {
    state,
    currentPlayerID,
    isConnecting,
    isConnected,
    isJoined,
    lastError,
    connect,
    disconnect,
    play,
    moveTo,
    placeTurret,
    shoot,
    updateRotation,
    upgradeTurret,
    upgradeWeapon,
    // Advanced: access to underlying tree instance
    tree: computed(() => tree.value) as ComputedRef<HeroDefenseStateTree | null>
  }
}
