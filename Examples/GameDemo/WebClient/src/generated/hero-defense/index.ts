// AUTO-GENERATED BY @swiftstatetree/sdk codegen.
// Do not edit this file directly.

import type { StateTreeRuntime, Logger, StatePatch, MapSubscriptions } from '@swiftstatetree/sdk/core'
import { StateTreeView } from '@swiftstatetree/sdk/core'
import type { LandState, Actions, ClientEvents, ServerEventSubscriptions, EventSubscription, EventHandler } from './bindings'
import { LAND_TYPE } from './bindings'
import { SCHEMA } from '../schema.js'
import type { MonsterState, PlayerState, TurretState } from '../defs'
import type { MoveToEvent, PlaceTurretEvent, PlayAction, PlayResponse, PlayerShootEvent, ShootEvent, TurretFireEvent, UpdateRotationEvent, UpgradeTurretEvent, UpgradeWeaponEvent } from '../defs'

// Re-export MapSubscriptions interface from SDK core
export type { MapSubscriptions } from '@swiftstatetree/sdk/core'

export interface StateTreeOptions {
  landID?: string
  playerID?: string
  deviceID?: string
  metadata?: Record<string, any>
  logger?: Logger
}

export class HeroDefenseStateTree {
  readonly landType: string = LAND_TYPE
  readonly state: LandState
  readonly actions: Actions
  readonly events: ClientEvents
  readonly on: ServerEventSubscriptions

  /** Type-safe subscriptions for monsters map */
  readonly monsters: MapSubscriptions<MonsterState>
  /** Type-safe subscriptions for players map */
  readonly players: MapSubscriptions<PlayerState>
  /** Type-safe subscriptions for turrets map */
  readonly turrets: MapSubscriptions<TurretState>

  /** Type-safe method for play action */
  readonly play: (payload: PlayAction) => Promise<PlayResponse>

  /** Type-safe method for moveTo client event */
  readonly moveTo: (payload: MoveToEvent) => void
  /** Type-safe method for placeTurret client event */
  readonly placeTurret: (payload: PlaceTurretEvent) => void
  /** Type-safe method for shoot client event */
  readonly shoot: (payload: ShootEvent) => void
  /** Type-safe method for updateRotation client event */
  readonly updateRotation: (payload: UpdateRotationEvent) => void
  /** Type-safe method for upgradeTurret client event */
  readonly upgradeTurret: (payload: UpgradeTurretEvent) => void
  /** Type-safe method for upgradeWeapon client event */
  readonly upgradeWeapon: (payload: UpgradeWeaponEvent) => void

  /** Type-safe subscription for playerShoot server event */
  readonly playerShoot: EventSubscription<PlayerShootEvent>
  /** Type-safe subscription for turretFire server event */
  readonly turretFire: EventSubscription<TurretFireEvent>

  private readonly runtime: StateTreeRuntime
  private readonly view: StateTreeView

  constructor(runtime: StateTreeRuntime, options?: StateTreeOptions) {
    this.runtime = runtime
    const landID = options?.landID ?? LAND_TYPE
    this.state = {} as LandState

    this.view = runtime.createView(landID, {
      schema: SCHEMA,  // Pass schema for accurate type checking
      playerID: options?.playerID,
      deviceID: options?.deviceID,
      metadata: options?.metadata,
      logger: options?.logger,
      onStateUpdate: (nextState) => {
        syncInto(this.state as any, nextState)
      },
      onError: (error, context) => {
        options?.logger?.error(`StateTree view error: ${error.message}`, context)
      }
    })

    this.play = (payload: PlayAction) => {
      return this.view.sendAction("Play", payload) as Promise<PlayResponse>
    }

    this.actions = {
      play: this.play,
    } as Actions

    this.moveTo = (payload: MoveToEvent) => {
      this.view.sendEvent("MoveTo", payload)
    }
    this.placeTurret = (payload: PlaceTurretEvent) => {
      this.view.sendEvent("PlaceTurret", payload)
    }
    this.shoot = (payload: ShootEvent) => {
      this.view.sendEvent("Shoot", payload)
    }
    this.updateRotation = (payload: UpdateRotationEvent) => {
      this.view.sendEvent("UpdateRotation", payload)
    }
    this.upgradeTurret = (payload: UpgradeTurretEvent) => {
      this.view.sendEvent("UpgradeTurret", payload)
    }
    this.upgradeWeapon = (payload: UpgradeWeaponEvent) => {
      this.view.sendEvent("UpgradeWeapon", payload)
    }

    this.events = {
      moveTo: this.moveTo,
      placeTurret: this.placeTurret,
      shoot: this.shoot,
      updateRotation: this.updateRotation,
      upgradeTurret: this.upgradeTurret,
      upgradeWeapon: this.upgradeWeapon,
    } as ClientEvents

    this.on = {
      playerShoot: (handler) => this.view.onServerEvent("PlayerShoot", handler),
      turretFire: (handler) => this.view.onServerEvent("TurretFire", handler),
    } as ServerEventSubscriptions

    // Initialize playerShoot server event subscription
    this.playerShoot = {
      subscribe: (handler: EventHandler<PlayerShootEvent>) => {
        return this.view.onServerEvent("PlayerShoot", handler)
      }
    } as EventSubscription<PlayerShootEvent>
    // Initialize turretFire server event subscription
    this.turretFire = {
      subscribe: (handler: EventHandler<TurretFireEvent>) => {
        return this.view.onServerEvent("TurretFire", handler)
      }
    } as EventSubscription<TurretFireEvent>

    // Initialize monsters map subscriptions using SDK core
    this.monsters = this.view.createMapSubscriptions<MonsterState>(
      '/monsters',
      (state) => state?.monsters as Record<string, MonsterState> | undefined
    )
    // Initialize players map subscriptions using SDK core
    this.players = this.view.createMapSubscriptions<PlayerState>(
      '/players',
      (state) => state?.players as Record<string, PlayerState> | undefined
    )
    // Initialize turrets map subscriptions using SDK core
    this.turrets = this.view.createMapSubscriptions<TurretState>(
      '/turrets',
      (state) => state?.turrets as Record<string, TurretState> | undefined
    )
  }

  async join() {
    return this.view.join()
  }

  destroy() {
    this.view.destroy()
  }

  get landId(): string {
    return this.view.landId
  }

  /**
   * Get the current player ID (set after successful join)
   */
  get currentPlayerID(): string | undefined {
    return this.view.currentPlayerID
  }

  /**
   * Expose underlying runtime for advanced scenarios.
   * This also ensures TypeScript treats the runtime field as used.
   */
  getRuntime(): StateTreeRuntime {
    return this.runtime
  }

  /**
   * Subscribe to patch operations.
   * Useful for tracking add/remove/replace operations on specific paths.
   * @param callback - Called for each patch with the patch info and decoded value
   * @returns Unsubscribe function
   */
  onPatch(callback: (patch: StatePatch, decodedValue?: any) => void): () => void {
    return this.view.onPatch(callback)
  }
}

function isPlainObject(value: any): value is Record<string, any> {
  if (!value || typeof value !== "object") {
    return false
  }
  const proto = Object.getPrototypeOf(value)
  return proto === Object.prototype || proto === null
}

function syncInto(target: any, source: any): void {
  if (source == null || typeof source !== "object") {
    return
  }

  for (const key of Object.keys(target)) {
    if (!(key in source)) {
      delete target[key]
    }
  }

  for (const [key, value] of Object.entries(source)) {
    const src: any = value
    const dst: any = target[key]

    if (Array.isArray(src)) {
      if (!Array.isArray(dst)) {
        target[key] = src.slice()
      } else {
        dst.length = 0
        for (const item of src) {
          dst.push(item)
        }
      }
      continue
    }

    if (src && typeof src === "object") {
      if (!isPlainObject(src)) {
        target[key] = src
        continue
      }
      if (!dst || typeof dst !== "object" || Array.isArray(dst) || !isPlainObject(dst)) {
        target[key] = {}
      }
      syncInto(target[key], src)
      continue
    }

    target[key] = src
  }
}
