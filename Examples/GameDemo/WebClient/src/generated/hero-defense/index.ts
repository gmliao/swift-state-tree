// AUTO-GENERATED BY @swiftstatetree/sdk codegen.
// Do not edit this file directly.

import type { StateTreeRuntime, Logger } from '@swiftstatetree/sdk/core'
import { StateTreeView } from '@swiftstatetree/sdk/core'
import type { LandState, Actions, ClientEvents, ServerEventSubscriptions } from './bindings'
import { LAND_TYPE } from './bindings'

export interface StateTreeOptions {
  landID?: string
  playerID?: string
  deviceID?: string
  metadata?: Record<string, any>
  logger?: Logger
}

export class HeroDefenseStateTree {
  readonly landType = LAND_TYPE
  readonly state: LandState
  readonly actions: Actions
  readonly events: ClientEvents
  readonly on: ServerEventSubscriptions

  private readonly runtime: StateTreeRuntime
  private readonly view: StateTreeView

  constructor(runtime: StateTreeRuntime, options?: StateTreeOptions) {
    this.runtime = runtime
    const landID = options?.landID ?? LAND_TYPE
    this.state = {} as LandState

    this.view = runtime.createView(landID, {
      playerID: options?.playerID,
      deviceID: options?.deviceID,
      metadata: options?.metadata,
      logger: options?.logger,
      onStateUpdate: (nextState) => {
        syncInto(this.state as any, nextState)
      },
      onError: (error, context) => {
        options?.logger?.error(`StateTree view error: ${error.message}`, context)
      }
    })

    this.actions = {
      play: (payload) => this.view.sendAction("Play", payload) as Promise<any>,
    } as Actions

    this.events = {
      moveTo: (payload) => this.view.sendEvent("MoveToEvent", payload),
    } as ClientEvents

    this.on = {
    } as ServerEventSubscriptions
  }

  async join() {
    return this.view.join()
  }

  destroy() {
    this.view.destroy()
  }

  get landId(): string {
    return this.view.landId
  }

  /**
   * Expose underlying runtime for advanced scenarios.
   * This also ensures TypeScript treats the runtime field as used.
   */
  getRuntime(): StateTreeRuntime {
    return this.runtime
  }
}

function syncInto(target: any, source: any): void {
  if (source == null || typeof source !== "object") {
    return
  }

  for (const key of Object.keys(target)) {
    if (!(key in source)) {
      delete target[key]
    }
  }

  for (const [key, value] of Object.entries(source)) {
    const src: any = value
    const dst: any = target[key]

    if (Array.isArray(src)) {
      if (!Array.isArray(dst)) {
        target[key] = src.slice()
      } else {
        dst.length = 0
        for (const item of src) {
          dst.push(item)
        }
      }
      continue
    }

    if (src && typeof src === "object") {
      if (!dst || typeof dst !== "object" || Array.isArray(dst)) {
        target[key] = {}
      }
      syncInto(target[key], src)
      continue
    }

    target[key] = src
  }
}
