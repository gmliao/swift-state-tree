// AUTO-GENERATED BY @swiftstatetree/sdk codegen.
// Do not edit this file directly.

import type { StateTreeRuntime, Logger, StatePatch } from '@swiftstatetree/sdk/core'
import { StateTreeView } from '@swiftstatetree/sdk/core'
import type { LandState, Actions, ClientEvents, ServerEventSubscriptions, EventSubscription, EventHandler } from './bindings'
import { LAND_TYPE } from './bindings'
import { SCHEMA } from '../schema.js'
import type { PauseVerificationAction, PauseVerificationResponse, ResumeVerificationAction, ResumeVerificationResponse, StartVerificationAction, StartVerificationResponse, TickProcessedEvent, TickSummaryEvent, VerificationCompleteEvent, VerificationFailedEvent, VerificationProgressEvent } from '../defs'

export interface StateTreeOptions {
  landID?: string
  playerID?: string
  deviceID?: string
  metadata?: Record<string, any>
  logger?: Logger
}

export class ReevaluationMonitorStateTree {
  readonly landType: string = LAND_TYPE
  readonly state: LandState
  readonly actions: Actions
  readonly events: ClientEvents
  readonly on: ServerEventSubscriptions

  /** Type-safe method for pauseVerification action */
  readonly pauseVerification: (payload: PauseVerificationAction) => Promise<PauseVerificationResponse>
  /** Type-safe method for resumeVerification action */
  readonly resumeVerification: (payload: ResumeVerificationAction) => Promise<ResumeVerificationResponse>
  /** Type-safe method for startVerification action */
  readonly startVerification: (payload: StartVerificationAction) => Promise<StartVerificationResponse>

  /** Type-safe subscription for tickProcessed server event */
  readonly tickProcessed: EventSubscription<TickProcessedEvent>
  /** Type-safe subscription for tickSummary server event */
  readonly tickSummary: EventSubscription<TickSummaryEvent>
  /** Type-safe subscription for verificationComplete server event */
  readonly verificationComplete: EventSubscription<VerificationCompleteEvent>
  /** Type-safe subscription for verificationFailed server event */
  readonly verificationFailed: EventSubscription<VerificationFailedEvent>
  /** Type-safe subscription for verificationProgress server event */
  readonly verificationProgress: EventSubscription<VerificationProgressEvent>

  private readonly runtime: StateTreeRuntime
  private readonly view: StateTreeView

  constructor(runtime: StateTreeRuntime, options?: StateTreeOptions) {
    this.runtime = runtime
    const landID = options?.landID ?? LAND_TYPE
    this.state = {} as LandState

    this.view = runtime.createView(landID, {
      schema: SCHEMA,  // Pass schema for accurate type checking
      playerID: options?.playerID,
      deviceID: options?.deviceID,
      metadata: options?.metadata,
      logger: options?.logger,
      onStateUpdate: (nextState) => {
        syncInto(this.state as any, nextState)
      },
      onError: (error, context) => {
        options?.logger?.error(`StateTree view error: ${error.message}`, context)
      }
    })

    this.pauseVerification = (payload: PauseVerificationAction) => {
      return this.view.sendAction("PauseVerification", payload) as Promise<PauseVerificationResponse>
    }
    this.resumeVerification = (payload: ResumeVerificationAction) => {
      return this.view.sendAction("ResumeVerification", payload) as Promise<ResumeVerificationResponse>
    }
    this.startVerification = (payload: StartVerificationAction) => {
      return this.view.sendAction("StartVerification", payload) as Promise<StartVerificationResponse>
    }

    this.actions = {
      pauseVerification: this.pauseVerification,
      resumeVerification: this.resumeVerification,
      startVerification: this.startVerification,
    } as Actions

    this.events = {
    } as ClientEvents

    this.on = {
      tickProcessed: (handler) => this.view.onServerEvent("TickProcessed", handler),
      tickSummary: (handler) => this.view.onServerEvent("TickSummary", handler),
      verificationComplete: (handler) => this.view.onServerEvent("VerificationComplete", handler),
      verificationFailed: (handler) => this.view.onServerEvent("VerificationFailed", handler),
      verificationProgress: (handler) => this.view.onServerEvent("VerificationProgress", handler),
    } as ServerEventSubscriptions

    // Initialize tickProcessed server event subscription
    this.tickProcessed = {
      subscribe: (handler: EventHandler<TickProcessedEvent>) => {
        return this.view.onServerEvent("TickProcessed", handler)
      }
    } as EventSubscription<TickProcessedEvent>
    // Initialize tickSummary server event subscription
    this.tickSummary = {
      subscribe: (handler: EventHandler<TickSummaryEvent>) => {
        return this.view.onServerEvent("TickSummary", handler)
      }
    } as EventSubscription<TickSummaryEvent>
    // Initialize verificationComplete server event subscription
    this.verificationComplete = {
      subscribe: (handler: EventHandler<VerificationCompleteEvent>) => {
        return this.view.onServerEvent("VerificationComplete", handler)
      }
    } as EventSubscription<VerificationCompleteEvent>
    // Initialize verificationFailed server event subscription
    this.verificationFailed = {
      subscribe: (handler: EventHandler<VerificationFailedEvent>) => {
        return this.view.onServerEvent("VerificationFailed", handler)
      }
    } as EventSubscription<VerificationFailedEvent>
    // Initialize verificationProgress server event subscription
    this.verificationProgress = {
      subscribe: (handler: EventHandler<VerificationProgressEvent>) => {
        return this.view.onServerEvent("VerificationProgress", handler)
      }
    } as EventSubscription<VerificationProgressEvent>

  }

  async join() {
    return this.view.join()
  }

  destroy() {
    this.view.destroy()
  }

  get landId(): string {
    return this.view.landId
  }

  /**
   * Get the current player ID (set after successful join)
   */
  get currentPlayerID(): string | undefined {
    return this.view.currentPlayerID
  }

  /**
   * Expose underlying runtime for advanced scenarios.
   * This also ensures TypeScript treats the runtime field as used.
   */
  getRuntime(): StateTreeRuntime {
    return this.runtime
  }

  /**
   * Subscribe to patch operations.
   * Useful for tracking add/remove/replace operations on specific paths.
   * @param callback - Called for each patch with the patch info and decoded value
   * @returns Unsubscribe function
   */
  onPatch(callback: (patch: StatePatch, decodedValue?: any) => void): () => void {
    return this.view.onPatch(callback)
  }
}

function isPlainObject(value: any): value is Record<string, any> {
  if (!value || typeof value !== "object") {
    return false
  }
  const proto = Object.getPrototypeOf(value)
  return proto === Object.prototype || proto === null
}

function syncInto(target: any, source: any): void {
  if (source == null || typeof source !== "object") {
    return
  }

  for (const key of Object.keys(target)) {
    if (!(key in source)) {
      delete target[key]
    }
  }

  for (const [key, value] of Object.entries(source)) {
    const src: any = value
    const dst: any = target[key]

    if (Array.isArray(src)) {
      if (!Array.isArray(dst)) {
        target[key] = src.slice()
      } else {
        dst.length = 0
        for (const item of src) {
          dst.push(item)
        }
      }
      continue
    }

    if (src && typeof src === "object") {
      if (!isPlainObject(src)) {
        target[key] = src
        continue
      }
      if (!dst || typeof dst !== "object" || Array.isArray(dst) || !isPlainObject(dst)) {
        target[key] = {}
      }
      syncInto(target[key], src)
      continue
    }

    target[key] = src
  }
}
