// AUTO-GENERATED BY @swiftstatetree/sdk codegen.
// Do not edit this file directly.

import { ref, reactive, computed } from 'vue'
import type { Ref, ComputedRef } from 'vue'
import { StateTreeRuntime } from '@swiftstatetree/sdk/core'
import { HeroDefenseStateTree } from '../hero-defense/index.js'
import { LAND_TYPE } from './bindings.js'
import type { HeroDefenseState } from '../defs.js'

interface ConnectOptions {
  wsUrl: string
  playerName?: string
  playerID?: string
  deviceID?: string
  landID?: string
  metadata?: Record<string, any>
}

const runtime = ref<StateTreeRuntime | null>(null)
const tree = ref<HeroDefenseStateTree | null>(null)
const state = ref<HeroDefenseState | null>(null) as Ref<HeroDefenseState | null>
const currentPlayerID = ref<string | null>(null)
const isConnecting = ref(false)
const isConnected = ref(false)
const isJoined = ref(false)
const lastError = ref<string | null>(null)

export interface HeroDefenseReplayComposableReturn {
  state: Ref<HeroDefenseState | null>
  currentPlayerID: Ref<string | null>
  isConnecting: Ref<boolean>
  isConnected: Ref<boolean>
  isJoined: Ref<boolean>
  lastError: Ref<string | null>
  connect: (opts: ConnectOptions) => Promise<void>
  disconnect: () => Promise<void>
  tree: ComputedRef<HeroDefenseStateTree | null>
}

export function useHeroDefenseReplay(): HeroDefenseReplayComposableReturn {
  async function connect(opts: ConnectOptions): Promise<void> {
    if (isConnecting.value || isConnected.value) return
    isConnecting.value = true
    lastError.value = null
    try {
      const r = new StateTreeRuntime()
      await r.connect(opts.wsUrl)
      runtime.value = r
      isConnected.value = true
      const metadata: Record<string, any> = opts.metadata ?? {}
      if (opts.playerName && opts.playerName.trim().length > 0) {
        metadata.username = opts.playerName.trim()
      }
      let landID: string | undefined = opts.landID
      if (landID && !landID.includes(':')) {
        landID = `${LAND_TYPE}:${landID}`
      }
      const t = new HeroDefenseStateTree(r, {
        landID: landID,
        playerID: opts.playerID,
        deviceID: opts.deviceID,
        metadata,
        logger: {
          debug: () => {},
          info: (msg) => console.log(`[StateTree]`, msg),
          warn: (msg) => console.warn(`[StateTree]`, msg),
          error: (msg) => console.error(`[StateTree]`, msg)
        }
      })
      tree.value = t
      const joinResult = await t.join()
      if (!joinResult.success) {
        throw new Error(joinResult.reason ?? 'Join failed')
      }
      currentPlayerID.value = joinResult.playerID ?? null
      const reactiveState = reactive(t.state as any) as HeroDefenseState
      state.value = reactiveState
      Object.defineProperty(t, 'state', {
        get: () => reactiveState,
        enumerable: true,
        configurable: true
      })
      r.onDisconnect(() => {
        if (isConnected.value || isJoined.value) {
          isConnected.value = false
          disconnect()
        }
      })
      isJoined.value = true
    } catch (error) {
      const message = (error as Error).message ?? String(error)
      lastError.value = message
      await disconnect()
    } finally {
      isConnecting.value = false
    }
  }
  async function disconnect(): Promise<void> {
    if (tree.value) tree.value.destroy()
    if (runtime.value && 'disconnect' in runtime.value && typeof runtime.value.disconnect === 'function') {
      runtime.value.disconnect()
    }
    runtime.value = null
    tree.value = null
    state.value = null
    currentPlayerID.value = null
    isConnected.value = false
    isJoined.value = false
  }
  return {
    state, currentPlayerID, isConnecting, isConnected, isJoined, lastError,
    connect, disconnect,
    tree: computed(() => tree.value) as ComputedRef<HeroDefenseStateTree | null>
  }
}
