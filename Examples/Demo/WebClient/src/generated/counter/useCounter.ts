// AUTO-GENERATED BY @swiftstatetree/sdk codegen.
// Do not edit this file directly.

import { ref, reactive, computed } from 'vue'
import type { Ref, ComputedRef } from 'vue'
import { StateTreeRuntime } from '@swiftstatetree/sdk/core'
import { CounterStateTree } from './index.js'
import { LAND_TYPE } from './bindings.js'
import type { CounterState } from '../defs.js'
import type { IncrementAction, IncrementResponse } from '../defs.js'

interface ConnectOptions {
  wsUrl: string
  playerName?: string
  playerID?: string
  deviceID?: string
  landID?: string  // Optional: specify room ID (format: "landType:instanceId" or just "instanceId")
  metadata?: Record<string, any>
}

const runtime = ref<StateTreeRuntime | null>(null)
const tree = ref<CounterStateTree | null>(null)

const state: Ref<CounterState | null> = ref<CounterState | null>(null)
const currentPlayerID = ref<string | null>(null)

const isConnecting = ref(false)
const isConnected = ref(false)
const isJoined = ref(false)
const lastError = ref<string | null>(null)

export interface CounterComposableReturn {
  state: Ref<CounterState | null>
  currentPlayerID: Ref<string | null>
  isConnecting: Ref<boolean>
  isConnected: Ref<boolean>
  isJoined: Ref<boolean>
  lastError: Ref<string | null>
  connect: (opts: ConnectOptions) => Promise<void>
  disconnect: () => Promise<void>
  increment: (payload: IncrementAction) => Promise<IncrementResponse>
  tree: ComputedRef<CounterStateTree | null>
}

export function useCounter(): CounterComposableReturn {

  async function connect(opts: ConnectOptions): Promise<void> {
    if (isConnecting.value || isConnected.value) return

    isConnecting.value = true
    lastError.value = null

    try {
      const r = new StateTreeRuntime()
      await r.connect(opts.wsUrl)
      runtime.value = r
      isConnected.value = true

      const metadata: Record<string, any> = opts.metadata ?? {}
      if (opts.playerName && opts.playerName.trim().length > 0) {
        metadata.username = opts.playerName.trim()
      }

      // Build landID: if provided, use as-is; if it's just instanceId (no colon), prepend landType
      let landID: string | undefined = opts.landID
      if (landID && !landID.includes(':')) {
        // If only instanceId provided (e.g., "room-123"), prepend landType
        landID = `${LAND_TYPE}:${landID}`
      }

      const t = new CounterStateTree(r, {
        landID: landID,
        playerID: opts.playerID,
        deviceID: opts.deviceID,
        metadata,
        logger: {
          debug: () => {},
          info: (msg) => console.log(`[StateTree]`, msg),
          warn: (msg) => console.warn(`[StateTree]`, msg),
          error: (msg) => console.error(`[StateTree]`, msg)
        }
      })
      tree.value = t

      const joinResult = await t.join()
      if (!joinResult.success) {
        throw new Error(joinResult.reason ?? 'Join failed')
      }

      currentPlayerID.value = joinResult.playerID ?? null
      
      // Make t.state reactive so Vue can track changes directly
      // This allows direct access like state.players[playerID].cookies in templates
      const reactiveState = reactive(t.state as CounterState)
      state.value = reactiveState
      
      // Override t.state to point to reactiveState so syncInto updates it directly
      // This way syncInto will update the reactive object and Vue tracks it automatically
      Object.defineProperty(t, 'state', {
        get: () => reactiveState,
        enumerable: true,
        configurable: true
      })
      
      // Set up disconnect callback for automatic cleanup
      r.onDisconnect(() => {
        if (isConnected.value || isJoined.value) {
          console.warn('⚠️ WebSocket disconnected, cleaning up...')
          // Update state immediately so watchers can react
          isConnected.value = false
          // disconnect() will set isJoined.value = false, triggering watchers
          disconnect()
        }
      })
      
      isJoined.value = true
    } catch (error) {
      const message = (error as Error).message ?? String(error)
      lastError.value = message
      console.error('Connect/join failed:', error)
      await disconnect()
    } finally {
      isConnecting.value = false
    }
  }

  async function disconnect(): Promise<void> {
    if (tree.value) {
      tree.value.destroy()
    }
    if (runtime.value && 'disconnect' in runtime.value && typeof runtime.value.disconnect === 'function') {
      runtime.value.disconnect()
    }
    runtime.value = null
    tree.value = null
    state.value = null
    currentPlayerID.value = null
    isConnected.value = false
    isJoined.value = false
  }

  async function increment(payload: IncrementAction): Promise<IncrementResponse> {
    if (!tree.value || !isJoined.value) {
      throw new Error('Not connected or not joined')
    }
    try {
      const res = await tree.value.actions.increment(payload)
      lastError.value = null
      return res
    } catch (error) {
      console.error('increment failed:', error)
      lastError.value = (error as Error).message ?? String(error)
      throw error
    }
  }

  return {
    state,
    currentPlayerID,
    isConnecting,
    isConnected,
    isJoined,
    lastError,
    connect,
    disconnect,
    increment,
    // Advanced: access to underlying tree instance
    tree: computed(() => tree.value) as ComputedRef<CounterStateTree | null>
  }
}
