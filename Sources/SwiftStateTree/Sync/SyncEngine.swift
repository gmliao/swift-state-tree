// Sources/SwiftStateTree/Sync/SyncEngine.swift

import Foundation

/// SyncEngine filters StateNode according to SyncPolicy and outputs StateSnapshot.
///
/// ## Implementation Status
///
/// ### ✅ Implemented
/// - **Full snapshot generation**: `snapshot(for:from:)` - generates complete state snapshots for late join scenarios
///   - Delegates to `StateNodeProtocol.snapshot(for:)` which is generated at compile time by the `@StateNodeBuilder` macro
///   - Avoids runtime reflection for better performance
/// - **Delta/Diff calculation**: Compare old and new snapshots, generate path-based diffs
///   - `generateDiff(for:from:onlyPaths:)` method - main entry point for diff generation
///   - Returns `StateUpdate.firstSync([StatePatch])` on first sync (cache is populated, includes any changes)
///   - Returns `StateUpdate.diff([StatePatch])` with path-based patches for subsequent updates
///   - `computeBroadcastDiff(from:onlyPaths:)` - computes shared broadcast fields diff
///   - `computePerPlayerDiff(for:from:onlyPaths:)` - computes player-specific fields diff
/// - **Cache management**: Cache broadcast and perPlayer snapshots for efficient diff calculation
///   - `lastBroadcastSnapshot` - shared cache for broadcast fields
///   - `lastPerPlayerSnapshots` - per-player cache dictionary
///   - `clearCacheForDisconnectedPlayer(_:)` - clear cache when a player disconnects
/// - **Diff merging**: `mergePatches(_:_:)` - combines broadcast and perPlayer diffs with per-player precedence
/// - **Path-based diff**: Uses JSON Pointer format (RFC 6901) for patch paths
/// - **Late join**: `lateJoinSnapshot(for:from:)` - optimized full snapshot generation for late join scenarios
/// - **First sync**: Returns `StateUpdate.firstSync([StatePatch])` to signal sync engine start (see DESIGN_SYNC_FIRSTSYNC.md)
///
/// ## Usage Recommendations
///
/// - **For late join** (first sync):
///   - Use `syncEngine.lateJoinSnapshot(for: playerID, from: state)` or `snapshot(for:from:)`
///   - Returns complete state snapshot
///
/// - **For incremental updates** (subsequent syncs):
///   - Use `syncEngine.generateDiff(for:from:onlyPaths:)`
///   - Returns `StateUpdate.firstSync([StatePatch])` on first sync (cache is populated, includes any changes)
///   - Returns `StateUpdate.diff([StatePatch])` with path-based patches for subsequent updates
///   - Returns `StateUpdate.noChange` when no changes are detected
///
/// - **For optimization**:
///   - Use `onlyPaths` parameter to limit diff calculation to specific paths
///   - Use `clearCacheForDisconnectedPlayer(_:)` to clear cache when a player disconnects
///
/// See [DESIGN_RUNTIME.md](../../../DESIGN_RUNTIME.md) for detailed design documentation.
public struct SyncEngine: Sendable {
    /// Cache for broadcast snapshot (shared across all players)
    private var lastBroadcastSnapshot: StateSnapshot?
    
    /// Cache for per-player snapshots (individual cache per player)
    private var lastPerPlayerSnapshots: [PlayerID: StateSnapshot] = [:]
    
    public init() {}

    /// Generate a full snapshot of the StateNode for a specific player or broadcast fields only
    ///
    /// This method is used for late join scenarios where a player needs to receive the complete
    /// state snapshot. It delegates to the `snapshot(for:)` method generated by the `@StateNodeBuilder` macro,
    /// which avoids runtime reflection and provides better performance.
    ///
    /// **Behavior**: Returns a complete state snapshot. For incremental updates, use `generateDiff(for:from:onlyPaths:)` instead.
    ///
    /// **Note**: For simple use cases, you can call `state.snapshot(for: playerID)` directly.
    ///
    /// - Parameters:
    ///   - playerID: The player ID to generate the snapshot for. If `nil`, only broadcast fields are included.
    ///   - state: The StateNode instance
    /// - Returns: A `StateSnapshot` containing filtered fields based on sync policies
    /// - Throws: `SyncError` if value conversion fails
    public func snapshot<State: StateNodeProtocol>(
        for playerID: PlayerID? = nil,
        from state: State,
        dirtyFields: Set<String>? = nil
    ) throws -> StateSnapshot {
        // Delegate to the macro-generated snapshot method
        // This avoids runtime reflection and provides better performance
        // If dirtyFields is provided, only dirty fields are serialized for optimization
        return try state.snapshot(for: playerID, dirtyFields: dirtyFields)
    }
    
    /// Generate a full snapshot and merge into an existing container
    ///
    /// This overload allows reusing a `StateSnapshot` container to avoid repeated allocations
    /// when generating snapshots for multiple players or in tight loops.
    ///
    /// - Parameters:
    ///   - playerID: The player ID to generate the snapshot for. If `nil`, only broadcast fields are included.
    ///   - state: The StateNode instance
    ///   - into: Container to reuse for the snapshot. Values will be merged into this container.
    /// - Returns: The same container with merged values
    /// - Throws: `SyncError` if value conversion fails
    public func snapshot<State: StateNodeProtocol>(
        for playerID: PlayerID?,
        from state: State,
        into container: inout StateSnapshot,
        dirtyFields: Set<String>? = nil
    ) throws -> StateSnapshot {
        let newSnapshot = try state.snapshot(for: playerID, dirtyFields: dirtyFields)
        container.merge(newSnapshot, overwrite: true)
        return container
    }
    
    // MARK: - Snapshot Extraction
    
    /// Extract broadcast fields snapshot (fields that are the same for all players)
    ///
    /// This method directly accesses broadcast fields from the StateNode without needing
    /// a specific player ID, since broadcast fields are identical for all players.
    ///
    /// **Default implementation**: Uses macro-generated method (microVersion) for optimal performance.
    /// For benchmarking purposes, use `extractBroadcastSnapshotMirrorVersion` to compare with Mirror-based implementation.
    ///
    /// - Parameter dirtyFields: Optional set of dirty field names. If provided, only dirty fields are serialized.
    private func extractBroadcastSnapshot<State: StateNodeProtocol>(
        from state: State,
        dirtyFields: Set<String>? = nil
    ) throws -> StateSnapshot {
        // Use macro-generated method to generate broadcast snapshot directly
        // This avoids runtime reflection (Mirror) and is much more efficient
        // If dirtyFields is provided, only dirty fields are serialized for optimization
        return try state.broadcastSnapshot(dirtyFields: dirtyFields)
    }
    
    /// Mirror-based implementation of extractBroadcastSnapshot (for benchmarking comparison)
    ///
    /// This method uses runtime reflection (Mirror) to extract broadcast fields.
    /// It is kept for performance comparison purposes in benchmarks.
    ///
    /// **Note**: This is the old implementation before macro optimization.
    /// The default `extractBroadcastSnapshot` uses macro-generated code which is much faster.
    ///
    /// - Parameter state: The StateNode instance
    /// - Returns: A `StateSnapshot` containing only broadcast fields
    public func extractBroadcastSnapshotMirrorVersion<State: StateNodeProtocol>(
        from state: State
    ) throws -> StateSnapshot {
        // Get all sync fields and filter for broadcast policy
        let syncFields = state.getSyncFields()
        let broadcastFields = syncFields.filter { $0.policyType == "broadcast" }
        
        // Use reflection to access broadcast field values directly from StateNode
        // For property wrappers, we need to extract wrappedValue
        let mirror = Mirror(reflecting: state)
        var broadcastValues: [String: SnapshotValue] = [:]
        
        for field in broadcastFields {
            // Property wrapper fields may be stored with underscore prefix (_fieldName)
            // or as the field name directly, depending on macro implementation
            let possibleLabels = [field.name, "_\(field.name)"]
            
            for label in possibleLabels {
                if let child = mirror.children.first(where: { $0.label == label }) {
                    var value = child.value
                    
                    // Extract wrappedValue from property wrapper if needed
                    // Sync<T> wraps the actual value, we need to unwrap it
                    let valueMirror = Mirror(reflecting: value)
                    let valueTypeName = String(describing: type(of: value))
                    
                    // Check if this is a Sync property wrapper
                    // Sync struct has: policy (SyncPolicy<Value>) and _wrappedValue (Value)
                    // We must find _wrappedValue, not policy
                    if valueTypeName.contains("Sync<") || valueTypeName.hasPrefix("Sync<") {
                        // This is a Sync property wrapper - find _wrappedValue explicitly
                        if let wrappedChild = valueMirror.children.first(where: { $0.label == "_wrappedValue" }) {
                            value = wrappedChild.value
                        } else {
                            // If _wrappedValue not found, this is an error
                            throw SyncError.unsupportedValue(
                                "Failed to extract _wrappedValue from Sync property wrapper. " +
                                "Type: \(valueTypeName), available children: \(valueMirror.children.map { $0.label ?? "nil" })"
                            )
                        }
                    } else if let wrappedChild = valueMirror.children.first(where: { $0.label == "wrappedValue" }) {
                        // Fallback: try wrappedValue (for other property wrappers)
                        value = wrappedChild.value
                    } else if valueTypeName.contains("SyncPolicy") {
                        // Error: we got the policy instead of the value
                        throw SyncError.unsupportedValue(
                            "Unexpectedly got SyncPolicy instead of wrappedValue from property wrapper. " +
                            "This indicates a bug in property wrapper extraction. Type: \(valueTypeName)"
                        )
                    }
                    // If none of the above, value is already the unwrapped value (not a property wrapper)
                    
                    // Convert value to SnapshotValue
                    // For broadcast fields, we directly use the raw value without player filtering
                    let snapshotValue = try SnapshotValue.make(from: value)
                    broadcastValues[field.name] = snapshotValue
                    break // Found and processed, move to next field
                }
            }
        }
        
        return StateSnapshot(values: broadcastValues)
    }
    
    /// Extract per-player fields snapshot (fields that differ per player)
    ///
    /// - Parameter dirtyFields: Optional set of dirty field names. If provided, only dirty fields are serialized.
    private func extractPerPlayerSnapshot<State: StateNodeProtocol>(
        for playerID: PlayerID,
        from state: State,
        dirtyFields: Set<String>? = nil
    ) throws -> StateSnapshot {
        // Generate snapshot for the specific player (with dirty tracking if provided)
        let fullSnapshot = try state.snapshot(for: playerID, dirtyFields: dirtyFields)
        
        // Filter to only include non-broadcast fields (perPlayer, masked, custom)
        let syncFields = state.getSyncFields()
        let perPlayerFieldNames = Set(
            syncFields.filter { $0.policyType != "broadcast" && $0.policyType != "serverOnly" }
                .map { $0.name }
        )
        
        var perPlayerValues: [String: SnapshotValue] = [:]
        for (key, value) in fullSnapshot.values where perPlayerFieldNames.contains(key) {
            perPlayerValues[key] = value
        }
        
        return StateSnapshot(values: perPlayerValues)
    }
    
    // MARK: - Snapshot Comparison
    
    /// Compare two snapshots and generate patches
    private func compareSnapshots(
        from oldSnapshot: StateSnapshot,
        to newSnapshot: StateSnapshot,
        onlyPaths: Set<String>? = nil
    ) -> [StatePatch] {
        compareSnapshots(
            from: oldSnapshot,
            to: newSnapshot,
            onlyPaths: onlyPaths,
            dirtyFields: nil
        )
    }
    
    /// Compare two snapshots and generate patches (with dirty tracking support)
    ///
    /// When `dirtyFields` is provided, only dirty fields are compared to avoid false positives.
    /// If a field exists in old snapshot but not in new snapshot, it's only considered a delete
    /// if the field is marked as dirty. Otherwise, it's skipped (assumed unchanged).
    private func compareSnapshots(
        from oldSnapshot: StateSnapshot,
        to newSnapshot: StateSnapshot,
        onlyPaths: Set<String>? = nil,
        dirtyFields: Set<String>?
    ) -> [StatePatch] {
        var patches: [StatePatch] = []
        
        // Get all keys from both snapshots
        let allKeys = Set(oldSnapshot.values.keys).union(Set(newSnapshot.values.keys))
        
        for key in allKeys {
            let path = "/\(key)"
            
            // Filter by onlyPaths if specified
            if let onlyPaths = onlyPaths, !onlyPaths.contains(path) && !anyPathMatches(path, in: onlyPaths) {
                continue
            }
            
            let oldValue = oldSnapshot.values[key]
            let newValue = newSnapshot.values[key]
            
            if let oldValue = oldValue, let newValue = newValue {
                // Both exist - compare recursively
                // If dirtyFields is provided, only compare if this field is dirty
                if let dirtyFields = dirtyFields {
                    if dirtyFields.contains(key) {
                        patches.append(contentsOf: compareSnapshotValues(
                            from: oldValue,
                            to: newValue,
                            basePath: path,
                            onlyPaths: onlyPaths
                        ))
                    }
                    // If not dirty, skip comparison (assume unchanged)
                } else {
                    // No dirty tracking - compare all fields
                    patches.append(contentsOf: compareSnapshotValues(
                        from: oldValue,
                        to: newValue,
                        basePath: path,
                        onlyPaths: onlyPaths
                    ))
                }
            } else if oldValue != nil && newValue == nil {
                // Deleted
                // ⚠️ Key: If dirtyFields is provided, only consider it a delete if the field is dirty
                if let dirtyFields = dirtyFields {
                    if dirtyFields.contains(key) {
                        // Field is dirty and missing - true delete
                        patches.append(StatePatch(path: path, operation: .delete))
                    }
                    // If not dirty, skip (assume unchanged, not deleted)
                } else {
                    // No dirty tracking - treat as delete
                    patches.append(StatePatch(path: path, operation: .delete))
                }
            } else if oldValue == nil, let newValue = newValue {
                // Added
                // If dirtyFields is provided, only add if field is dirty
                if let dirtyFields = dirtyFields {
                    if dirtyFields.contains(key) {
                        patches.append(StatePatch(path: path, operation: .set(newValue)))
                    }
                    // If not dirty, skip (shouldn't happen, but safe to skip)
                } else {
                    // No dirty tracking - treat as add
                    patches.append(StatePatch(path: path, operation: .set(newValue)))
                }
            }
        }
        
        return patches
    }
    
    /// Recursively compare two SnapshotValues and generate patches
    private func compareSnapshotValues(
        from oldValue: SnapshotValue,
        to newValue: SnapshotValue,
        basePath: String,
        onlyPaths: Set<String>? = nil
    ) -> [StatePatch] {
        var patches: [StatePatch] = []
        
        // If values are equal, no change
        if oldValue == newValue {
            return patches
        }
        
        // Handle different types or changed values
        switch (oldValue, newValue) {
        case (.object(let oldObj), .object(let newObj)):
            // Compare objects recursively
            let allKeys = Set(oldObj.keys).union(Set(newObj.keys))
            
            for key in allKeys {
                let path = "\(basePath)/\(escapeJsonPointer(key))"
                
                // Filter by onlyPaths if specified
                if let onlyPaths = onlyPaths, !anyPathMatches(path, in: onlyPaths) {
                    continue
                }
                
                let oldVal = oldObj[key]
                let newVal = newObj[key]
                
                if let oldVal = oldVal, let newVal = newVal {
                    // Both exist - recurse
                    patches.append(contentsOf: compareSnapshotValues(
                        from: oldVal,
                        to: newVal,
                        basePath: path,
                        onlyPaths: onlyPaths
                    ))
                } else if oldVal != nil && newVal == nil {
                    // Deleted
                    patches.append(StatePatch(path: path, operation: .delete))
                } else if oldVal == nil, let newVal = newVal {
                    // Added
                    patches.append(StatePatch(path: path, operation: .set(newVal)))
                }
            }
            
        case (.array(let oldArr), .array(let newArr)):
            // For arrays, treat as a whole value change for simplicity
            // More sophisticated diffing can be added later
            if oldArr != newArr {
                patches.append(StatePatch(path: basePath, operation: .set(newValue)))
            }
            
        default:
            // Different types or primitive value changed
            patches.append(StatePatch(path: basePath, operation: .set(newValue)))
        }
        
        return patches
    }
    
    /// Escape a key for JSON Pointer format (RFC 6901)
    private func escapeJsonPointer(_ key: String) -> String {
        return key.replacingOccurrences(of: "~", with: "~0")
                  .replacingOccurrences(of: "/", with: "~1")
    }
    
    /// Check if a path matches any path in the onlyPaths set (including prefix matches)
    private func anyPathMatches(_ path: String, in onlyPaths: Set<String>) -> Bool {
        for allowedPath in onlyPaths {
            if path == allowedPath || path.hasPrefix(allowedPath + "/") {
                return true
            }
        }
        return false
    }
    
    // MARK: - Diff Computation
    
    /// Compute broadcast diff (shared across all players)
    private mutating func computeBroadcastDiff<State: StateNodeProtocol>(
        from state: State,
        onlyPaths: Set<String>?,
        dirtyFields: Set<String>? = nil
    ) throws -> [StatePatch] {
        // Generate current broadcast snapshot (only dirty fields if dirtyFields is provided)
        let currentBroadcast = try extractBroadcastSnapshot(from: state, dirtyFields: dirtyFields)
        
        // Check if we have cached broadcast snapshot
        guard let lastBroadcast = lastBroadcastSnapshot else {
            // First time: cache and return empty (first sync uses full snapshot)
            // Note: On first sync, we always generate full snapshot (dirtyFields is ignored)
            lastBroadcastSnapshot = currentBroadcast
            return []
        }
        
        // Compare and generate patches (with dirty tracking if provided)
        let patches = compareSnapshots(
            from: lastBroadcast,
            to: currentBroadcast,
            onlyPaths: onlyPaths,
            dirtyFields: dirtyFields
        )
        
        // Update cache by merging dirty fields into existing cache
        // This avoids generating a full snapshot when using dirty tracking
        if let dirtyFields = dirtyFields, !dirtyFields.isEmpty, var cachedSnapshot = lastBroadcastSnapshot {
            // Merge only dirty fields into cached snapshot (more efficient than regenerating full snapshot)
            for (key, value) in currentBroadcast.values {
                cachedSnapshot.values[key] = value
            }
            lastBroadcastSnapshot = cachedSnapshot
        } else {
            // No dirty tracking or no cache, update cache with current snapshot
            lastBroadcastSnapshot = currentBroadcast
        }
        
        return patches
    }
    
    /// Compute per-player diff (individual for each player)
    private mutating func computePerPlayerDiff<State: StateNodeProtocol>(
        for playerID: PlayerID,
        from state: State,
        onlyPaths: Set<String>?,
        dirtyFields: Set<String>? = nil
    ) throws -> [StatePatch] {
        // Generate current per-player snapshot (only dirty fields if dirtyFields is provided)
        let currentPerPlayer = try extractPerPlayerSnapshot(for: playerID, from: state, dirtyFields: dirtyFields)
        
        // Check if we have cached per-player snapshot
        guard let lastPerPlayer = lastPerPlayerSnapshots[playerID] else {
            // First time: cache and return empty (first sync uses full snapshot)
            // Note: On first sync, we always generate full snapshot (dirtyFields is ignored)
            lastPerPlayerSnapshots[playerID] = currentPerPlayer
            return []
        }
        
        // Compare and generate patches (with dirty tracking if provided)
        let patches = compareSnapshots(
            from: lastPerPlayer,
            to: currentPerPlayer,
            onlyPaths: onlyPaths,
            dirtyFields: dirtyFields
        )
        
        // Update cache by merging dirty fields into existing cache
        // This avoids generating a full snapshot when using dirty tracking
        if let dirtyFields = dirtyFields, !dirtyFields.isEmpty, var cachedSnapshot = lastPerPlayerSnapshots[playerID] {
            // Merge only dirty fields into cached snapshot (more efficient than regenerating full snapshot)
            for (key, value) in currentPerPlayer.values {
                cachedSnapshot.values[key] = value
            }
            lastPerPlayerSnapshots[playerID] = cachedSnapshot
        } else {
            // No dirty tracking or no cache, update cache with current snapshot
            lastPerPlayerSnapshots[playerID] = currentPerPlayer
        }
        
        return patches
    }
    
    /// Merge broadcast and per-player patches (per-player takes precedence)
    private func mergePatches(
        _ broadcast: [StatePatch],
        _ perPlayer: [StatePatch]
    ) -> [StatePatch] {
        var merged: [StatePatch] = []
        var seenPaths: Set<String> = []
        
        // Add broadcast patches first
        for patch in broadcast {
            if !seenPaths.contains(patch.path) {
                merged.append(patch)
                seenPaths.insert(patch.path)
            }
        }
        
        // Add per-player patches (may override broadcast)
        for patch in perPlayer {
            if !seenPaths.contains(patch.path) {
                merged.append(patch)
                seenPaths.insert(patch.path)
            } else {
                // Per-player takes precedence - replace existing patch
                if let index = merged.firstIndex(where: { $0.path == patch.path }) {
                    merged[index] = patch
                }
            }
        }
        
        return merged
    }
    
    // MARK: - Main Diff Generation
    
    /// Generate a diff update for a specific player
    ///
    /// This method computes the differences between the current state and the last cached snapshot,
    /// generating path-based patches that describe what changed.
    ///
    /// On the first call for a player (when cache is empty), this method returns `.firstSync([StatePatch])`
    /// to signal that the sync engine has started and will begin sending diff updates.
    /// The patches array may contain changes that occurred between join and the first diff generation.
    ///
    /// See [DESIGN_SYNC_FIRSTSYNC.md](../../../DESIGN_SYNC_FIRSTSYNC.md) for detailed design documentation.
    ///
    /// - Parameters:
    ///   - playerID: The player ID to generate the diff for
    ///   - state: The current StateNode instance
    ///   - onlyPaths: Optional set of paths to limit the diff calculation to (for optimization)
    /// - Returns: A `StateUpdate` containing either no changes, first sync signal, or a list of patches
    /// - Throws: `SyncError` if value conversion fails
    public mutating func generateDiff<State: StateNodeProtocol>(
        for playerID: PlayerID,
        from state: State,
        onlyPaths: Set<String>? = nil
    ) throws -> StateUpdate {
        try generateDiff(
            for: playerID,
            from: state,
            onlyPaths: onlyPaths,
            useDirtyTracking: false
        )
    }
    
    /// Generate a diff update for a specific player (with dirty tracking optimization)
    ///
    /// This is an optimized version that uses dirty tracking to reduce computation.
    /// Only dirty fields are compared, reducing serialization and comparison overhead.
    ///
    /// **Important**: When using dirty tracking, the comparison logic considers dirty fields to avoid
    /// false positives (e.g., a field present in old snapshot but absent in new snapshot is only
    /// considered a delete if it's marked as dirty).
    ///
    /// - Parameters:
    ///   - playerID: The player ID to generate the diff for
    ///   - state: The current StateNode instance
    ///   - onlyPaths: Optional set of paths to limit the diff calculation to (for optimization)
    ///   - useDirtyTracking: If `true`, only compare dirty fields. Default is `false` for backward compatibility.
    /// - Returns: A `StateUpdate` containing either no changes, first sync signal, or a list of patches
    /// - Throws: `SyncError` if value conversion fails
    public mutating func generateDiff<State: StateNodeProtocol>(
        for playerID: PlayerID,
        from state: State,
        onlyPaths: Set<String>? = nil,
        useDirtyTracking: Bool
    ) throws -> StateUpdate {
        // Check if this is the first sync for this specific player
        // Note: broadcast cache may already exist (from other players), but perPlayer cache is per-player
        let isFirstSyncForPlayer = lastPerPlayerSnapshots[playerID] == nil
        
        // Get dirty fields if dirty tracking is enabled
        let dirtyFields: Set<String>? = useDirtyTracking && state.isDirty() ? state.getDirtyFields() : nil
        
        // IMPORTANT: We must compute diffs BEFORE returning firstSync because:
        // 1. computeBroadcastDiff and computePerPlayerDiff populate the cache
        // 2. If we return early, cache won't be populated, causing infinite firstSync returns
        // 3. The cache needs to be set up so subsequent calls can generate proper diffs
        
        // Compute broadcast diff (shared across all players)
        // This will populate lastBroadcastSnapshot if it's the first time
        let broadcastDiff = try computeBroadcastDiff(
            from: state,
            onlyPaths: onlyPaths?.filter { isBroadcastPath($0, state: state) },
            dirtyFields: dirtyFields
        )
        
        // Compute per-player diff (individual for each player)
        // This will populate lastPerPlayerSnapshots[playerID] if it's the first time
        let perPlayerDiff = try computePerPlayerDiff(
            for: playerID,
            from: state,
            onlyPaths: onlyPaths?.filter { isPerPlayerPath($0, state: state) },
            dirtyFields: dirtyFields
        )
        
        // Merge patches (per-player takes precedence)
        let mergedPatches = mergePatches(broadcastDiff, perPlayerDiff)
        
        // Now that cache is populated, we can safely return firstSync signal
        // Include patches to handle any changes between join and first diff generation
        if isFirstSyncForPlayer {
            return .firstSync(mergedPatches)
        }
        
        // Return result
        if mergedPatches.isEmpty {
            return .noChange
        } else {
            return .diff(mergedPatches)
        }
    }
    
    // MARK: - Path Filtering
    
    /// Check if a path belongs to a broadcast field
    private func isBroadcastPath<State: StateNodeProtocol>(_ path: String, state: State) -> Bool {
        // Extract field name from path (first segment after "/")
        let pathComponents = path.split(separator: "/", omittingEmptySubsequences: true)
        guard let fieldName = pathComponents.first.map(String.init) else {
            return false
        }
        
        // Check sync fields for broadcast policy
        let syncFields = state.getSyncFields()
        if let field = syncFields.first(where: { $0.name == fieldName }) {
            return field.policyType == "broadcast"
        }
        
        return false
    }
    
    /// Check if a path belongs to a per-player field
    private func isPerPlayerPath<State: StateNodeProtocol>(_ path: String, state: State) -> Bool {
        // Extract field name from path (first segment after "/")
        let pathComponents = path.split(separator: "/", omittingEmptySubsequences: true)
        guard let fieldName = pathComponents.first.map(String.init) else {
            return false
        }
        
        // Check sync fields for non-broadcast policy
        let syncFields = state.getSyncFields()
        if let field = syncFields.first(where: { $0.name == fieldName }) {
            return field.policyType != "broadcast" && field.policyType != "serverOnly"
        }
        
        return false
    }
    
    // MARK: - Cache Management
    
    /// Clear cache for a disconnected player
    ///
    /// Use this method when a player explicitly leaves or disconnects.
    /// After clearing the cache, the next `generateDiff` call for this player will return
    /// `.firstSync([StatePatch])` instead of regular diffs.
    ///
    /// **Important**: Only call this when you are certain the player has disconnected.
    /// Clearing cache for an active player will cause incorrect sync behavior.
    ///
    /// - Parameter playerID: The player ID whose cache should be cleared
    public mutating func clearCacheForDisconnectedPlayer(_ playerID: PlayerID) {
        lastPerPlayerSnapshots.removeValue(forKey: playerID)
    }
    
    // MARK: - Cache Population Helper
    
    /// Populate cache for a player if not already populated
    ///
    /// This helper method ensures that both broadcast and per-player caches are set up
    /// so that subsequent `generateDiff` calls can correctly detect changes.
    ///
    /// **Important**: This method populates both broadcast and per-player caches to establish
    /// a baseline. Without this, changes between join and first `generateDiff` would be lost.
    ///
    /// - Parameters:
    ///   - playerID: The player ID to populate cache for
    ///   - state: The StateNode instance
    /// - Throws: `SyncError` if value conversion fails
    private mutating func populateCacheIfNeeded<State: StateNodeProtocol>(
        for playerID: PlayerID,
        from state: State
    ) throws {
        // Populate broadcast cache if not already populated
        // (may already exist from other players, but we ensure it's set)
        if lastBroadcastSnapshot == nil {
            lastBroadcastSnapshot = try extractBroadcastSnapshot(from: state)
        }
        
        // Populate per-player cache for this player
        // (must be set for this specific player to establish baseline)
        if lastPerPlayerSnapshots[playerID] == nil {
            lastPerPlayerSnapshots[playerID] = try extractPerPlayerSnapshot(for: playerID, from: state)
        }
    }
    
    // MARK: - Late Join
    
    /// Generate a full snapshot for late join scenarios
    ///
    /// This method ensures that late-joining players receive a complete state snapshot.
    /// It also populates the cache so that subsequent `generateDiff` calls can correctly
    /// detect changes that occur between join and the first diff generation.
    ///
    /// **Important**: This method populates both broadcast and per-player caches to establish
    /// a baseline. Without this, changes between join and first `generateDiff` would be lost.
    ///
    /// - Parameters:
    ///   - playerID: The player ID to generate the snapshot for
    ///   - state: The StateNode instance
    /// - Returns: A complete `StateSnapshot` containing all visible fields
    /// - Throws: `SyncError` if value conversion fails
    public mutating func lateJoinSnapshot<State: StateNodeProtocol>(
        for playerID: PlayerID,
        from state: State
    ) throws -> StateSnapshot {
        // Generate snapshot
        let snapshot = try snapshot(for: playerID, from: state)
        
        // Populate cache so subsequent generateDiff calls can detect changes
        try populateCacheIfNeeded(for: playerID, from: state)
        
        return snapshot
    }
    
    /// Generate a full snapshot for late join scenarios and merge into an existing container
    ///
    /// This overload allows reusing a `StateSnapshot` container to avoid repeated allocations.
    /// It also populates the cache like the main `lateJoinSnapshot` method.
    ///
    /// - Parameters:
    ///   - playerID: The player ID to generate the snapshot for
    ///   - state: The StateNode instance
    ///   - into: Container to reuse for the snapshot. Values will be merged into this container.
    /// - Returns: The same container with merged values
    /// - Throws: `SyncError` if value conversion fails
    public mutating func lateJoinSnapshot<State: StateNodeProtocol>(
        for playerID: PlayerID,
        from state: State,
        into container: inout StateSnapshot
    ) throws -> StateSnapshot {
        let newSnapshot = try state.snapshot(for: playerID, dirtyFields: nil)
        container.merge(newSnapshot, overwrite: true)
        
        // Populate cache so subsequent generateDiff calls can detect changes
        try populateCacheIfNeeded(for: playerID, from: state)
        
        return container
    }
}

