// Sources/SwiftStateTree/Sync/SyncEngine.swift

import Foundation

/// SyncEngine filters StateTree according to SyncPolicy and outputs StateSnapshot.
///
/// **Current Implementation**: This method delegates to `StateTreeProtocol.snapshot(for:)`,
/// which is generated at compile time by the `@StateTreeBuilder` macro, avoiding runtime reflection.
///
/// **Future Extensions**: SyncEngine will be responsible for:
/// - Diff calculation: Compare old and new snapshots, generate path-based diffs
/// - Cache management: Cache broadcast and perPlayer snapshots
/// - Batch synchronization: Optimize multi-player synchronization performance
///
/// **Usage Recommendations**:
/// - Simple scenarios: Use `state.snapshot(for: playerID)` directly
/// - When SyncEngine features are needed: Use `SyncEngine().snapshot(for:from:)`
public struct SyncEngine: Sendable {
    public init() {}

    /// Generate a snapshot of the StateTree for a specific player
    ///
    /// This method delegates to the `snapshot(for:)` method generated by the `@StateTreeBuilder` macro,
    /// which avoids runtime reflection and provides better performance.
    ///
    /// **Note**: For simple use cases, you can call `state.snapshot(for: playerID)` directly.
    ///
    /// - Parameters:
    ///   - playerID: The player ID to generate the snapshot for
    ///   - state: The StateTree instance
    /// - Returns: A `StateSnapshot` containing filtered fields based on sync policies
    /// - Throws: `SyncError` if value conversion fails
    public func snapshot<State: StateTreeProtocol>(
        for playerID: PlayerID,
        from state: State
    ) throws -> StateSnapshot {
        // Delegate to the macro-generated snapshot method
        // This avoids runtime reflection and provides better performance
        return try state.snapshot(for: playerID)
    }
}

