// Sources/SwiftStateTree/StateTree/StateNodeProtocol.swift

/// Protocol that marks a type as a StateNode.
/// 
/// StateNode is a node in the state tree that can be nested recursively.
/// Types conforming to this protocol must:
/// - Be marked with `@StateNodeBuilder` macro (required for compile-time validation and code generation)
/// - Have stored properties marked with `@Sync` (for synchronization) or `@Internal` (for server-only use)
/// - Computed properties are automatically skipped from validation
/// - Conform to `Sendable` for thread-safe usage
///
/// The `@StateNodeBuilder` macro automatically generates:
/// - `getSyncFields()` method implementation
/// - `validateSyncFields()` method implementation
/// - `snapshot(for:)` method implementation
/// - `broadcastSnapshot()` method implementation (for efficient broadcast snapshot generation)
/// - `PatchableState` conformance via extension
/// - `_$parentPath` and `_$patchRecorder` properties (for `PatchableState` conformance)
///
/// Example:
/// ```swift
/// @StateNodeBuilder
/// struct GameStateRootNode: StateNodeProtocol {
///     @Sync(.broadcast)
///     var players: [PlayerID: PlayerStateNode] = [:]
///     
///     @Sync(.serverOnly)
///     var hiddenDeck: [Card] = []
///     
///     @Internal
///     var lastProcessedTimestamp: Date = Date()
///     
///     var totalPlayers: Int {
///         players.count
///     }
/// }
/// ```
public protocol StateNodeProtocol: Sendable, SchemaMetadataProvider {
    /// Initialize a new instance of the StateNode.
    ///
    /// All StateNode types must provide a parameterless initializer.
    /// If all stored properties have default values, Swift will automatically generate this initializer.
    ///
    /// Example:
    /// ```swift
    /// @StateNodeBuilder
    /// struct GameState: StateNodeProtocol {
    ///     @Sync(.broadcast)
    ///     var players: [PlayerID: PlayerState] = [:]  // Default value
    ///     
    ///     // Swift automatically generates init() {}
    /// }
    /// ```
    init()
    
    /// Get all fields marked with @Sync in this StateNode
    /// 
    /// Returns an array of `SyncFieldInfo` containing the name and policy type
    /// of each field marked with `@Sync`.
    ///
    /// This method is automatically generated by the `@StateNodeBuilder` macro.
    ///
    /// Example:
    /// ```swift
    /// let fields = gameState.getSyncFields()
    /// // Returns: [SyncFieldInfo(name: "players", policyType: "broadcast"), ...]
    /// ```
    func getSyncFields() -> [SyncFieldInfo]
    
    /// Get metadata for all fields in this StateNode type
    ///
    /// Returns an array of `FieldMetadata` containing the name, type, policy, and node kind
    /// of each field. This is used for schema generation.
    ///
    /// This method is automatically generated by the `@StateNodeBuilder` macro.
    static func getFieldMetadata() -> [FieldMetadata]
    
    /// Validate that all stored properties have @Sync or @Internal markers
    /// 
    /// Returns `true` if all stored properties are marked with `@Sync` or `@Internal`.
    /// Since validation happens at compile time with the `@StateNodeBuilder` macro,
    /// this method always returns `true` for macro-generated implementations.
    ///
    /// This method is automatically generated by the `@StateNodeBuilder` macro.
    ///
    /// Validation rules (enforced at compile time):
    /// - ✅ `@Sync` marked fields: require synchronization
    /// - ✅ `@Internal` marked fields: server-only use, skip validation
    /// - ✅ Computed properties: automatically skipped
    /// - ❌ Unmarked stored properties: compile-time error
    func validateSyncFields() -> Bool
    
    /// Generate a snapshot of the StateNode for a specific player or broadcast fields only
    /// 
    /// Returns a `StateSnapshot` containing only the fields that should be
    /// synchronized to the specified player, according to their `@Sync` policies.
    ///
    /// - Parameter playerID: The player ID to generate the snapshot for. If `nil`, only broadcast fields are included.
    /// - Parameter dirtyFields: Optional set of dirty field names. If provided, only dirty fields are serialized for optimization.
    ///
    /// This method is automatically generated by the `@StateNodeBuilder` macro.
    /// It avoids runtime reflection by directly accessing `@Sync` fields at compile time.
    ///
    /// Example:
    /// ```swift
    /// let snapshot = gameState.snapshot(for: playerID)
    /// // Returns: StateSnapshot with filtered fields based on sync policies
    /// 
    /// let broadcastSnapshot = gameState.snapshot(for: nil)
    /// // Returns: StateSnapshot with only broadcast fields
    /// 
    /// // With dirty tracking optimization:
    /// let dirtyFields = gameState.getDirtyFields()
    /// let optimizedSnapshot = gameState.snapshot(for: playerID, dirtyFields: dirtyFields)
    /// // Returns: StateSnapshot with only dirty fields serialized
    /// ```
    func snapshot(for playerID: PlayerID?, dirtyFields: Set<String>?) throws -> StateSnapshot
    
    /// Generate a broadcast snapshot (for efficient broadcast snapshot generation)
    ///
    /// Returns a `StateSnapshot` containing only broadcast fields, without needing a player ID.
    /// This method is optimized for broadcast snapshot generation and avoids runtime reflection.
    ///
    /// - Parameter dirtyFields: Optional set of dirty field names. If provided, only dirty fields are serialized for optimization.
    ///
    /// This method is automatically generated by the `@StateNodeBuilder` macro.
    /// It directly accesses broadcast fields at compile time, avoiding Mirror reflection.
    ///
    /// Example:
    /// ```swift
    /// let broadcastSnapshot = gameState.broadcastSnapshot()
    /// // Returns: StateSnapshot with only broadcast fields (players, round, turn, etc.)
    /// 
    /// // With dirty tracking optimization:
    /// let dirtyFields = gameState.getDirtyFields()
    /// let optimizedSnapshot = gameState.broadcastSnapshot(dirtyFields: dirtyFields)
    /// // Returns: StateSnapshot with only dirty broadcast fields serialized
    /// ```
    func broadcastSnapshot(dirtyFields: Set<String>?) throws -> StateSnapshot
    
    /// Extract once and classify: one tree walk yields broadcast + per-player for all players.
    ///
    /// Typically implemented by the `@StateNodeBuilder` macro; hand-written implementations are also supported.
    /// Reduces redundant tree walks: one pass fills both broadcast and per-player snapshots instead of
    /// 1 broadcast extraction + N per-player extractions (1+N tree walks).
    ///
    /// - Parameters:
    ///   - playerIDs: All players that need per-player snapshots (e.g. connected, non-initial-syncing players).
    ///   - dirtyFields: Optional dirty field filter (same semantics as snapshot/broadcastSnapshot).
    /// - Returns: (broadcastSnapshot, perPlayerSnapshotByPlayerID)
    /// - Throws: `SyncError` if value conversion fails.
    ///
    /// **Default implementation**: Falls back to calling broadcastSnapshot() + snapshot(for:) for each player.
    /// Hand-written or macro-generated implementations should do one tree walk for better performance.
    func snapshotForSync(playerIDs: [PlayerID], dirtyFields: Set<String>?) throws -> (broadcast: StateSnapshot, perPlayer: [PlayerID: StateSnapshot])
    
    // MARK: - Dirty Tracking
    
    /// Check if any @Sync field has been modified since last clear
    ///
    /// Returns `true` if any field marked with `@Sync` has been modified.
    /// This method is automatically generated by the `@StateNodeBuilder` macro.
    ///
    /// Example:
    /// ```swift
    /// if gameState.isDirty() {
    ///     // Generate diff only for dirty fields
    ///     let update = try syncEngine.generateDiffWithDirty(for: playerID, from: gameState)
    ///     gameState.clearDirty()
    /// }
    /// ```
    func isDirty() -> Bool
    
    /// Get all dirty field names
    ///
    /// Returns a set of field names that have been marked as dirty.
    /// This method is automatically generated by the `@StateNodeBuilder` macro.
    ///
    /// Example:
    /// ```swift
    /// let dirtyFields = gameState.getDirtyFields()
    /// // Returns: Set(["players", "round"]) if those fields are dirty
    /// ```
    func getDirtyFields() -> Set<String>
    
    /// Clear all dirty flags for all @Sync fields
    ///
    /// Resets the dirty state for all fields marked with `@Sync`.
    /// This method is automatically generated by the `@StateNodeBuilder` macro.
    ///
    /// Example:
    /// ```swift
    /// gameState.clearDirty()  // Clear all dirty flags
    /// ```
    mutating func clearDirty()
}

// MARK: - Default Implementation for snapshotForSync

extension StateNodeProtocol {
    /// Default implementation: falls back to 1 broadcast + N per-player extractions.
    ///
    /// Hand-written or macro-generated implementations should override this to do one tree walk
    /// for better performance (avoiding 1+N tree walks).
    public func snapshotForSync(playerIDs: [PlayerID], dirtyFields: Set<String>?) throws -> (broadcast: StateSnapshot, perPlayer: [PlayerID: StateSnapshot]) {
        let broadcast = try broadcastSnapshot(dirtyFields: dirtyFields)
        var perPlayer: [PlayerID: StateSnapshot] = [:]
        perPlayer.reserveCapacity(playerIDs.count)
        for playerID in playerIDs {
            let fullSnapshot = try snapshot(for: playerID, dirtyFields: dirtyFields)
            // Filter to per-player fields only
            let syncFields = getSyncFields()
            let perPlayerFieldNames = Set(
                syncFields.filter { $0.policyType != .broadcast && $0.policyType != .serverOnly }
                    .map { $0.name }
            )
            var perPlayerValues: [String: SnapshotValue] = [:]
            for (key, value) in fullSnapshot.values where perPlayerFieldNames.contains(key) {
                perPlayerValues[key] = value
            }
            perPlayer[playerID] = StateSnapshot(values: perPlayerValues)
        }
        return (broadcast, perPlayer)
    }
}
