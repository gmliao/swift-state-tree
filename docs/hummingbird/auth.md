[English](auth.md) | [中文版](auth.zh-TW.md)

# JWT and Guest Mode

Hummingbird version's WebSocket connections support JWT authentication and Guest mode.

## Design Notes

- WebSocket in browser environments can easily pass tokens through query parameters
- JWT validation completes during handshake phase, preventing unauthorized connections from entering game layer
- Guest mode allows connections without tokens, used for demo or low-barrier experience

## Connection Parameters

JWT token is passed through query parameter:

```
ws://host:port/game?token=<jwt-token>
```

If no token is provided:

- `allowGuestMode = true`: Allow connection, use guest session on join
- `allowGuestMode = false`: Reject connection directly

## JWTConfiguration

```swift
let jwtConfig = JWTConfiguration(
    secretKey: "your-secret-key",
    algorithm: .HS256,
    validateExpiration: true
)

// Create LandHost to manage HTTP server and game logic
let host = LandHost(configuration: LandHost.HostConfiguration(
    host: "localhost",
    port: 8080
))

// Register land type with JWT configuration
try await host.register(
    landType: "demo",
    land: demoLand,
    initialState: GameState(),
    webSocketPath: "/game",
    configuration: LandServerConfiguration(
        jwtConfig: jwtConfig,
        allowGuestMode: true
    )
)

try await host.run()
```

Environment variables can also be used:

- `JWT_SECRET_KEY`
- `JWT_ALGORITHM`
- `JWT_ISSUER` (optional)
- `JWT_AUDIENCE` (optional)

## PlayerSession Priority

Priority order for player/device/metadata sources on join:

1. join request content
2. JWT payload
3. guest session

## Flow Overview

```
Client --(ws?token=...)--> Hummingbird Adapter
  -> JWT validate (if configured)
  -> TransportAdapter.onConnect(authInfo)
  -> join request
  -> CanJoin / OnJoin
```

## JWT Token Generation

### Server-Side Generation (Example)

In real applications, JWT tokens are usually generated by authentication services. Here's an example using SwiftJWT:

```swift
import SwiftJWT

struct MyClaims: Claims {
    let playerID: String
    let deviceID: String?
    let exp: Date
    let iat: Date
}

func generateJWT(playerID: String, deviceID: String?) throws -> String {
    let myHeader = Header(typ: "JWT")
    let expiration = Date().addingTimeInterval(3600 * 2) // 2 hours
    let myClaims = MyClaims(
        playerID: playerID,
        deviceID: deviceID,
        exp: expiration,
        iat: Date()
    )
    
    var myJWT = JWT(header: myHeader, claims: myClaims)
    let jwtSigner = JWTSigner.hs256(key: Data("your-secret-key".utf8))
    let signedJWT = try myJWT.sign(using: jwtSigner)
    
    return signedJWT
}
```

### Client-Side Generation (TypeScript Example)

On the client, you can use Web Crypto API to generate JWT:

```typescript
async function generateJWT(
  secretKey: string,
  payload: { playerID: string; deviceID?: string },
  expiresInHours: number = 2
): Promise<string> {
  const header = { alg: 'HS256', typ: 'JWT' };
  const now = Math.floor(Date.now() / 1000);
  const exp = now + (expiresInHours * 3600);
  
  const jwtPayload = {
    ...payload,
    iat: now,
    exp: exp
  };
  
  // Encode header and payload
  const encodedHeader = btoa(JSON.stringify(header))
    .replace(/\+/g, '-')
    .replace(/\//g, '_')
    .replace(/=/g, '');
  const encodedPayload = btoa(JSON.stringify(jwtPayload))
    .replace(/\+/g, '-')
    .replace(/\//g, '_')
    .replace(/=/g, '');
  
  // Create signature
  const message = `${encodedHeader}.${encodedPayload}`;
  const keyData = new TextEncoder().encode(secretKey);
  const cryptoKey = await crypto.subtle.importKey(
    'raw',
    keyData,
    { name: 'HMAC', hash: 'SHA-256' },
    false,
    ['sign']
  );
  
  const signature = await crypto.subtle.sign(
    'HMAC',
    cryptoKey,
    new TextEncoder().encode(message)
  );
  
  const encodedSignature = btoa(String.fromCharCode(...new Uint8Array(signature)))
    .replace(/\+/g, '-')
    .replace(/\//g, '_')
    .replace(/=/g, '');
  
  return `${encodedHeader}.${encodedPayload}.${encodedSignature}`;
}

// Usage example
const token = await generateJWT('your-secret-key', {
  playerID: 'player-123',
  deviceID: 'device-456'
});

// Connect to WebSocket
const ws = new WebSocket(`ws://localhost:8080/game?token=${token}`);
```

## Complete Configuration Examples

### Basic JWT Configuration

```swift
import SwiftStateTreeHummingbird

// Configure JWT
let jwtConfig = JWTConfiguration(
    secretKey: "your-secret-key-here",
    algorithm: .HS256,
    validateExpiration: true,
    validateIssuer: false,
    expectedIssuer: nil,
    validateAudience: false,
    expectedAudience: nil
)

// Create LandHost
let host = LandHost(configuration: LandHost.HostConfiguration(
    host: "localhost",
    port: 8080
))

// Register land type with JWT configuration (no guest mode)
try await host.register(
    landType: "game",
    land: gameLand,
    initialState: GameState(),
    webSocketPath: "/game",
    configuration: LandServerConfiguration(
        jwtConfig: jwtConfig,
        allowGuestMode: false  // Don't allow Guest mode
    )
)

try await host.run()
```

### Using Environment Variables

```swift
// Load configuration from environment variables
let jwtConfig = JWTConfiguration.fromEnvironment() ?? JWTConfiguration(
    secretKey: "default-secret-key",
    algorithm: .HS256
)

// Create LandHost
let host = LandHost(configuration: LandHost.HostConfiguration(
    host: "localhost",
    port: 8080
))

// Register land type with JWT configuration (allow guest mode as fallback)
try await host.register(
    landType: "game",
    land: gameLand,
    initialState: GameState(),
    webSocketPath: "/game",
    configuration: LandServerConfiguration(
        jwtConfig: jwtConfig,
        allowGuestMode: true  // Allow Guest mode as fallback
    )
)

try await host.run()
```

### Environment Variable Settings

```bash
# .env file or environment variables
export JWT_SECRET_KEY="your-secret-key-here"
export JWT_ALGORITHM="HS256"
export JWT_ISSUER="my-game-server"  # Optional
export JWT_AUDIENCE="my-game-client"  # Optional
```

## Guest Mode

### Use Cases

Guest mode is suitable for the following scenarios:

- **Demo or test environments**: Don't need complete authentication flow
- **Quick experience**: Lower barrier to entry for users
- **Development phase**: Simplify development and testing process

### Guest Mode Configuration

```swift
// Create LandHost
let host = LandHost(configuration: LandHost.HostConfiguration(
    host: "localhost",
    port: 8080
))

// Register land type with guest mode enabled
try await host.register(
    landType: "game",
    land: gameLand,
    initialState: GameState(),
    webSocketPath: "/game",
    configuration: LandServerConfiguration(
        jwtConfig: jwtConfig,  // JWT configuration (optional)
        allowGuestMode: true   // Allow Guest mode
    )
)

try await host.run()
```

### Guest Session Handling

Handle Guest players in Land's `OnJoin` handler:

```swift
Rules {
    OnJoin { state, ctx in
        // Check if Guest
        if ctx.playerID.rawValue.hasPrefix("guest-") {
            // Special handling for Guest players
            state.players[ctx.playerID] = PlayerState(
                name: "Guest \(ctx.playerID.rawValue.suffix(8))",
                isGuest: true
            )
        } else {
            // Normal player handling
            state.players[ctx.playerID] = PlayerState(
                name: ctx.metadata["displayName"] ?? ctx.playerID.rawValue,
                isGuest: false
            )
        }
    }
}
```

### Guest Mode Limitations

It's recommended to implement some limitations in Guest mode:

```swift
Rules {
    CanJoin { state, session, ctx in
        // Limit Guest player count
        let guestCount = state.players.values.filter { $0.isGuest }.count
        if session.playerID.rawValue.hasPrefix("guest-") && guestCount >= 10 {
            return .deny(reason: "Too many guest players")
        }
        return .allow(playerID: PlayerID(session.playerID))
    }
    
    HandleAction(PremiumAction.self) { state, action, ctx in
        // Guest players cannot perform certain actions
        let player = state.players[ctx.playerID]
        if player?.isGuest == true {
            throw LandError.actionDenied("Guest players cannot perform this action")
        }
        // Normal processing...
    }
}
```

## Admin Routes

### Enable Admin Routes

```swift
import SwiftStateTreeHummingbird

// Create Admin authentication middleware
let adminAuth = AdminAuthMiddleware(
    jwtValidator: jwtValidator,  // Optional: Use JWT validation
    apiKey: "your-admin-api-key"  // Optional: Use API Key
)

// Create LandHost
let host = LandHost(configuration: LandHost.HostConfiguration(
    host: "localhost",
    port: 8080
))

// Register admin routes
try await host.registerAdminRoutes(
    adminAuth: adminAuth,
    enableAdminRoutes: true
)

// Register land types as usual
try await host.register(
    landType: "game",
    land: gameLand,
    initialState: GameState(),
    webSocketPath: "/game",
    configuration: serverConfig
)

try await host.run()
```

### Admin Roles

Admin routes support three roles:

- **`admin`**: Full admin permissions (highest)
- **`operator`**: Operation permissions (medium)
- **`viewer`**: View permissions (lowest)

Role hierarchy: `admin` > `operator` > `viewer`

### Admin JWT Token

Admin JWT token needs to include `adminRole` in metadata:

```swift
// Generate Admin JWT token
let adminPayload = JWTPayload(
    playerID: "admin-user",
    deviceID: nil,
    metadata: [
        "adminRole": "admin"  // or "operator", "viewer"
    ]
)
```

### Admin API Key

API Key can also be used for authentication:

```swift
let adminAuth = AdminAuthMiddleware(
    apiKey: "your-secure-api-key"
)
```

API Key can be passed through:

1. **HTTP Header**: `X-API-Key: your-secure-api-key`
2. **Query Parameter**: `?apiKey=your-secure-api-key`

### Admin Route Endpoints

After enabling Admin routes, the following endpoints are automatically provided:

#### GET /admin/lands

List all rooms:

```bash
curl -H "X-API-Key: your-secure-api-key" http://localhost:8080/admin/lands
```

Response:
```json
[
  "game-room-1",
  "game-room-2",
  "lobby-main"
]
```

#### GET /admin/lands/:landID

Get statistics for a specific room:

```bash
curl -H "X-API-Key: your-secure-api-key" http://localhost:8080/admin/lands/game-room-1
```

Response:
```json
{
  "playerCount": 3,
  "createdAt": "2024-01-01T00:00:00Z",
  "lastActivity": "2024-01-01T01:00:00Z"
}
```

#### GET /admin/stats

Get system statistics:

```bash
curl -H "X-API-Key: your-secure-api-key" http://localhost:8080/admin/stats
```

Response:
```json
{
  "totalLands": 5,
  "totalPlayers": 12
}
```

#### DELETE /admin/lands/:landID

Delete a specific room (requires admin permission):

```bash
curl -X DELETE -H "X-API-Key: your-secure-api-key" http://localhost:8080/admin/lands/game-room-1
```

## Error Handling

### JWT Validation Errors

When JWT validation fails, connection is rejected:

```swift
// Handle connection errors on client
ws.onerror = { error in
    if error.localizedDescription.contains("JWT") {
        // JWT validation failed, need to re-login
        handleAuthError()
    }
}
```

### Guest Mode Errors

When Guest mode is disabled and no JWT token is provided:

```swift
// Server will reject connection
// Client will receive connection error
```

### Admin Route Errors

Admin routes return standard HTTP status codes:

- `401 Unauthorized`: No authentication provided or authentication failed
- `403 Forbidden`: Insufficient permissions
- `404 Not Found`: Resource doesn't exist

```swift
// Handle Admin API errors
let response = try await fetchAdminAPI(endpoint: "/admin/lands")
if response.status == 401 {
    // Need to re-authenticate
} else if response.status == 403 {
    // Insufficient permissions
}
```

## Security Recommendations

### 1. Secret Key Management

- **Don't hardcode secret key in code**: Use environment variables or key management services
- **Use strong keys**: At least 32-character random string
- **Rotate regularly**: Regularly change secret key

```swift
// ✅ Correct: Read from environment variable
let secretKey = ProcessInfo.processInfo.environment["JWT_SECRET_KEY"] ?? ""

// ❌ Wrong: Hardcoded in code
let secretKey = "my-secret-key"
```

### 2. Token Expiration Time

Set reasonable token expiration time:

```swift
// Set expiration time when generating token
let expiration = Date().addingTimeInterval(3600 * 2) // 2 hours
```

### 3. HTTPS/WSS

In production, always use HTTPS and WSS:

```swift
// Production should use WSS
let wsURL = "wss://your-domain.com/game?token=\(token)"
```

### 4. Admin API Key

- **Use strong random string**: At least 32 characters
- **Limit access sources**: Use IP whitelist or VPN
- **Log all Admin operations**: For auditing

### 5. Guest Mode Limitations

In production, it's recommended to implement limitations for Guest mode:

```swift
// Limit Guest player count
// Limit Guest player actions
// Regularly clean up inactive Guest players
```

## Related Documentation

- [Hummingbird Integration](README.md) - Understand complete server configuration
- [Transport Layer](../transport/README.md) - Understand connection management mechanisms
- [FAQ](../FAQ.md) - Frequently asked questions
