
# PLC Framework：實務經驗架構分享

最近在做一個 side project（網路狀態同步框架，之後會開源），
在分析狀態屬性的時候發現狀態好像可以用幾個通用的屬性分類，並且用在效能分析建議上面。
因此整理出這個狀態的評估分析框架，目前是自己的想法，應該有不足或不正確的地方，歡迎大家討論補充。

這套 PLC 框架最初來自我在政府教育平台與多人遊戲的系統設計經驗 —— 每一個錯誤決策，都換來實際的系統瓶頸。因此整理出這套方法，希望讓工程師做架構決策時有憑有據，而不是完全依靠直覺。

---

分散式系統領域已有非常多成熟理論，例如 CAP/PACELC 聚焦於一致性與延遲的權衡、CQRS 專注在讀寫分離、CRDT 處理衝突合併、Clean Architecture 指引軟體模組化方向。

不過工程師在實際設計「每一個狀態」時，仍經常面臨這些問題：

- 這個變數要不要保存？
- 要存在哪裡？
- 更新後要多快讓客戶端知道？

然後發現狀態的屬性選擇是很重要的，
很多效能問題其實不是演算法不夠好，
而是變數保存與同步策略設計錯了。

我們的選擇幾乎都靠經驗與直覺來決定
沒有一個方法能夠系統化地比較、評估與說服他人

尤其在：

- 教新人時：只有講解片段，難以建立全貌
- 與產品與企劃討論時：需要跟他們說他們設計的功能狀態同步消耗太高，但是沒有好的方法

剛好我在分析狀態的時候發現，好像可以整理一個圖表來簡單表示現在的狀態屬性，
然後可以一起討論是否調整狀態的屬性提升系統效能。

---

## 以聊天室訊息為例

常見做法是：

每來一則訊息 → 立刻寫入資料庫 → 寫完才通知客戶端

這會導致：

a. 新訊息延遲（等寫入完成才更新 UI）
b. 訊息量大時，DB 被寫爆

然後工程師就開始「靠直覺優化」：

| 策略 | 說法 | 問題 |
|------|------|------|
| a. 不存（逃避雖可恥但有用） | OK 啊都私聊也沒人留存 | 訊息遺失風險 |
| b. 批次/非同步寫入 | UI超順，後台慢慢補 | 當機就 RIP |
| c. 先寫 Cache 再回寫 DB | 性能佳、資料風險可控 | 設計複雜度提高 |

---

## 回到根本：什麼是狀態？什麼是系統？

### 1. 狀態（State）

狀態 = 某一刻的「快照值」。

例子:
- player.hp = 80
- cart.items = [A, B, C]
- session.isLoggedIn = true
- room.players[123].position = (x, y)

你從伺服器抓到資料那一瞬間,就是一個 snapshot.
之後會不會變,你不知道 —— 那個是「之後的狀態」。

所以:
- 狀態本身是值(value)
- 可以被讀,可以被改
- 改變之間是「狀態遷移」,不是同一個狀態

### 2. 系統（System）

裝狀態的容器，同時也得負責照顧狀態

照顧狀態就會花資源，我們把這叫做 Cost（資源消耗）

分為：

| 種類 | 內容 | 例子 |
|------|------|------|
| 計算消耗 Compute Cost | 狀態變化需要算 | 更新頻率、同步邏輯、序列化、ACL… |
| 移動消耗 Movement Cost | 狀態需要被搬來搬去 | Server→Client、Server→DB、節點同步 |

---

## Capacity（資源上限）

由硬體 + 軟體決定：

- CPU、記憶體、磁碟、網路
- 程式架構、演算法設計

我們的目標很簡單：

不要讓成本超過容量
不然系統就會爆炸

可以拆成:
- **Compute Capacity**: CPU / thread 能承受的總計算量
- **Movement Capacity**: 網路, I/O 能承受的總搬運量

PLC 跟 Cost 決定:
- 每個狀態平均吃掉多少資源
- 在固定的 Capacity 下,最多可以有多少:
  - 同時在線
  - 房間數
  - 每秒操作數
  - 同時查詢 / 更新

你可以用一句話概括:

每個狀態的 PLC 配置,決定了它的 Cost;
所有狀態的 Cost 加起來,不能超過系統的 Capacity.

---

## 系統分層: State Level vs System Level

狀態可以調,系統的硬體能力本身是固定的.
調整平行運算,多執行緒... 那已經是「換系統」。

所以要分兩層來看:

### State Level (狀態層)

這一層關心的是:
- 每一份 state 的 PLC 是什麼?
- 它的 Cost 大概是多少?
- 它會增加多少 Change / Flow?
- 它跟其他 state 有沒有不合理的組合?

你在這一層可以做:
- 調整 Lifetime (縮短 / 延長)
- 調整 Placement (DB → Redis → Memory → Client)
- 調整 Consistency (強一致 → session-level → 弱一致)
- 降低不必要的更新頻率
- 合併多個變更成一個
- 做 Diff,做快取

這些都是「不用換系統」就可以做的優化.

### System Level (系統層)

這一層是:
- CPU 核心數
- Memory 大小
- Disk / SSD / IOPS
- Network 頻寬
- Thread 模型
- Actor / Runtime / Scheduler
- 是否多機分散式
- 是否有 Gateway / Load balancer

這些東西不是你改狀態就能變的.
要動它 = 架構重建,換系統.

例如:
- 單執行緒 → 多執行緒
- 單機 → 多台 Server
- 沒有 Redis → 加 Redis
- 沒有快取 → 加 CDN
- 沒有 Room Engine → 加 StateTree

這是 System Level 的重構.

### 兩層之間的關係

可以用一個簡單的圖:

```
        ┌─────────────────────────────┐
        │       System Level         │
        │  CPU / Thread / Memory     │
        │  Network / Disk / Runtime  │
        └─────────────▲──────────────┘
                      │  提供 Capacity
                      │
        ┌─────────────┴──────────────┐
        │       State Level          │
        │  每個 State 的 PLC 配置       │
        │  → 決定自己的 Cost            │
        └─────────────────────────────┘
```

- System Level 給你一個固定的「桶子大小」
- State Level 決定每一顆「石頭」多大,多重
- 全部丟進去不能超過桶子的容量

---

## 狀態的三大屬性：PLC 模型

好，現在我們知道系統有 Cost 和 Capacity 的限制了。

那接下來要問的是：**狀態本身有什麼屬性會影響我們的決策？**

我在分析的時候發現，每次做狀態設計決策時，好像都在考慮三個維度：

---

### Place（放置位置）

Place 問的是:這份狀態「物理上」放在哪一層?

常見例子:
- Client (App / Browser / local cache)
- Edge / CDN
- Server memory (in-memory state, room state)
- Redis / Memcached 等快取
- Database (MySQL / PostgreSQL / ...)
- Log / Data lake (偏離線)

放得越「近 CPU」→ Movement Cost 越低
放得越「遠」→ Movement Cost 越高 (跨網路,跨磁碟)

| 放置位置 | 優點 | 缺點 |
|---------|------|------|
| Client | 快,成本最低 | 不安全,易消失,可作弊 |
| Edge / CDN | 靠近用戶,分散負載 | 成本較高,不適合動態資料 |
| Server RAM | 快,權威性高 | 重啟就沒了 |
| Cache (Redis) | 多伺服器共享 | 一樣可能掉資料 |
| Database | 最安全,持久化 | 最慢,成本最高 |
| Log / Data lake | 離線分析 | 不適合即時查詢 |

---

### Lifetime（狀態生命週期）

兩部分組成：

1. **生命長度** → 這個狀態會存在多久?
   
   例子:
   - 一次 request 內短暫使用 → request scope
   - 使用者 session 活 30 分鐘 → session scope
   - 購物車活 10 分鐘沒動就過期
   - 產品資料每 1 小時更新一次
   - 交易紀錄需要永久保留
   - 玩家位置 (很短,遊戲結束就沒了) vs 聊天訊息 (永久保存)
   - **注意**:同樣是「玩家位置」,對戰遊戲 (很短命) vs MMORPG (需要保存下線位置) 屬性不同
   
   Lifetime 越長:
   - 要維持正確就越久,越累
   - 需要處理的更新 / 遷移次數越多
   
   Lifetime 越短:
   - 不小心不一致或過期的風險比較小
   - 可以做 aggressive cache / in-memory
   
2. **生命價值** → 過去的狀態是否還有意義?
   
   例子:
   - 玩家位置 (舊位置沒意義) vs 戰績記錄 (歷史很重要)

更新頻率不是生命週期的一部分
它是 Compute Cost 的一部分

例子：

| 狀態 | 遊戲更新頻率 | Web系統更新頻率 | 本質（狀態分類） |
|------|-------------|----------------|-----------------|
| 玩家 HP | 很快 | 偶爾 | HP 狀態仍相同 |
| User Profile | 幾乎不變 | 批次大量更新 | Profile 不會「變別的東西」 |

頻率是場景造成的結果
不是狀態屬性

---

### Consistency（一致性）

Client 以為自己看到的值,跟系統端目前認為的值,有多接近?

可以粗分幾種層級:
- **Strong**:幾乎沒有時間差,改了就要立刻反映
- **Session-level**:對「自己這個 session」要很準,但別的使用者改了可能稍微延遲一下才看到
- **Weak / Stale-acceptable**:允許舊資料,例如公告,排行榜,熱門商品清單,推薦

Consistency 越強:
- Compute Cost ↑ (更多檢查,鎖,同步邏輯)
- Movement Cost ↑ (需要更多更新,更多訊息)

分成兩種維度:

| 類別 | 問題句 | 例子 |
|------|--------|------|
| 時間一致性 Time | 要多久同步? | 延遲超過 100ms 就被罵 |
| 數值一致性 Value | 能不能短暫錯? | 玩家位置差 1-2 像素 OK,之後會校正 |

---

## PLC → Cost 的關係

可以用一張表把直覺變成「分析工具」:

### PLC × Cost 矩陣表

這個矩陣表用來快速了解每個屬性對兩種成本的影響:

| 屬性 | Compute Cost 影響 | Movement Cost 影響 |
|------|------------------|-------------------|
| **Place (位置)** | 影響較小<br>(主要是讀寫邏輯) | **影響大**<br>放得越遠 → Movement Cost ↑<br>放得越近 (memory) → Movement Cost ↓ |
| **Lifetime (生命週期)** | **影響大**<br>活越久 → 維護更新的總成本 ↑<br>活越短 → 允許更多暫時不一致,負擔 ↓ | 影響中等<br>(需要更多遷移/備份) |
| **Consistency (一致性)** | **影響大**<br>要求越強 → 檢查/鎖/同步邏輯 ↑ | **影響大**<br>要求越強 → 需要更多更新/訊息 ↑ |

### 使用這個矩陣表做決策

當你想要降低 Cost 時:

- **想降低 Compute Cost** → 調整 Lifetime 或 Consistency
- **想降低 Movement Cost** → 調整 Place 或 Consistency
- **兩個都想降低** → 需要同時調整多個屬性

### 三個屬性一起作用的組合

實際上三個屬性會「一起作用」,產生不同的成本組合:

| 組合 | Compute Cost | Movement Cost | 總 Cost | 例子 |
|------|-------------|--------------|---------|------|
| 高 Lifetime + 遠 Placement + 強 Consistency | 高 | 高 | **最高** | 金融交易主帳本 |
| 短 Lifetime + 近 Placement + 弱 Consistency | 低 | 低 | **最低** | 暫時 UI 狀態,快取 |
| 高 Lifetime + 近 Placement + 強 Consistency | 高 | 中 | **中高** | 遊戲排行榜 (需要即時但可放記憶體) |
| 短 Lifetime + 遠 Placement + 強 Consistency | 中 | 高 | **中高** | 對戰遊戲位置 (短命但需要權威性) |

---

## 實際案例：用 PLC 三軸定位

好，現在我們有了 PLC 三個維度了。

讓我們用實際案例來看看，這三個維度如何幫助我們做決策：

### 案例 1：玩家位置

| 維度 | 分析 | 說明 |
|------|------|------|
| **Place** | Server RAM（客戶端預測可參考） | 需要權威性，但可以讓客戶端先預測 |
| **Life** | 很短、舊值沒意義 | 只對「現在」有意義，過去的位置沒用 |
| **Time Consistency** | 超高（>100ms 就穿牆） | 不能延遲，否則會看到玩家穿牆 |
| **Value Consistency** | 偏高（但可容忍少量誤差後再修正） | 位置可以局部校正，不需要完全精確 |

**結論**：只存 Server RAM，不同步到 DB，但同步要很快。

---

### 案例 2：聊天室訊息

| 維度 | 分析 | 說明 |
|------|------|------|
| **Place** | Cache + DB | 要快也要保存 |
| **Life** | 長期保存很重要 | 歷史訊息很重要，要永久保存 |
| **Time Consistency** | 中（晚一點沒差） | 晚個幾秒沒關係 |
| **Value Consistency** | 高（訊息不能亂） | 訊息順序和內容不能錯 |

**結論**：既要保存，也不必超低延遲，可以用非同步寫入。

---

### 案例 3：Session 狀態

| 維度 | 分析 | 說明 |
|------|------|------|
| **Place** | Cache / Server RAM | 短期使用，不需要持久化 |
| **Life** | 短（30 分鐘 session） | 過期就失效，不需要永久保存 |
| **Time Consistency** | 低 | 不需要即時同步 |
| **Value Consistency** | 高（認證不能錯） | 必須準確，但可以容忍短暫不一致 |

**結論**：放 Cache 或 Server RAM，不需要寫 DB，降低每次請求的查詢成本。

---

## 用 PLC 框架做決策討論

有了上面的狀態案例，我們可以針對狀態案例來分析討論。

因為屬性是可以調整的，調整屬性有可能改變消耗。不過改變屬性應該是產品設計師與工程師一起討論，都是一種 trade off。

### 發現不合理的設計

PLC 框架可以用來討論目前的狀態設計也許不合理：

- **Place 不合理**：Session 的 Place 在 DB，每個請求都必須查詢 DB
  → 問題：Session 是短期的，不需要持久化，應該放 Cache 或 Server RAM
  
- **Lifetime 不合理**：對戰遊戲的玩家位置（很短命，遊戲結束就沒了）卻寫入資料庫永久保存
  → 問題：對戰遊戲的位置是短命的，不需要永久保存，浪費儲存空間和寫入成本
  → 注意：MMORPG 的玩家位置可能需要保存（下線位置、傳送點），所以要看遊戲類型
  
- **Consistency 不合理**：聊天訊息設計成時間一致性很高（毫秒級）
  → 問題：聊天訊息不需要毫秒級同步，晚個幾秒沒關係，可以降低系統負擔

**重點**:同樣的狀態 (如「位置」),在不同的應用場景下,PLC 屬性會不同.設計時要根據實際場景來決定屬性.

### PLC × Cost 決策矩陣表：團隊討論工具

這個矩陣表用來幫助團隊一起分析狀態設計,並討論調整方案.

#### 使用步驟

1. **列出所有重要狀態** - 把系統中重要的狀態都列出來
2. **填寫 PLC 屬性** - Place、Lifetime、Consistency
3. **用矩陣表估算 Cost** - 根據 PLC 屬性估算 Compute Cost 和 Movement Cost (高/中/低)
4. **找出問題** - 哪些狀態的 Cost 太高? 哪些組合不合理?
5. **提出調整方案** - 調整哪些屬性可以降低 Cost? 調整後的新 Cost 是多少?
6. **團隊討論** - 調整後的影響是什麼? 產品/企劃/工程師是否都能接受?

#### 範例：聊天系統狀態分析

**訊息狀態調整**

| 項目 | 調整前 | 調整後 | 變化 |
|------|--------|--------|------|
| Place | DB | Cache + DB | - |
| Lifetime | 永久 | 永久 | - |
| Consistency | Time: 毫秒級<br>Value: 高 | Time: 秒級<br>Value: 高 | Time ↓ |
| **Compute Cost** | **高** | **中** | **↓** |
| **Movement Cost** | **高** | **中** | **↓** |
| **總 Cost** | **高** | **中** | **↓** |
| 問題/影響 | DB 寫入瓶頸 | 延遲 1-2 秒 | ✅ 可接受 |

**Session 狀態調整**

| 項目 | 調整前 | 調整後 | 變化 |
|------|--------|--------|------|
| Place | DB | Redis | - |
| Lifetime | 30 分鐘 | 30 分鐘 | - |
| Consistency | Time: 低<br>Value: 高 | Time: 低<br>Value: 高 | - |
| **Compute Cost** | **中** | **低** | **↓** |
| **Movement Cost** | **高** | **低** | **↓** |
| **總 Cost** | **高** | **低** | **↓** |
| 問題/影響 | 每次請求查 DB | 重啟可能遺失 | ⚠️ 需備份策略 |

#### 討論重點

使用這個矩陣表討論時,重點關注:

- **Cost 降低** vs **使用者體驗影響**: 是否可接受?
- **資料安全性**: 調整後會不會有風險?
- **系統複雜度**: 調整後會不會增加維護成本?
- **未來擴展性**: 這個設計能撐多久?

---

## 調整時的兩個大原則

### 原則 1: 調整任何一個 PLC,必須重新評估其他兩個

因為:
- 改 Placement → Lifetime / Consistency 的成本都會變
- 改 Lifetime → Placement / Consistency 都要重看
- 改 Consistency → Placement / Lifetime 的負擔也會被放大 / 縮小

「調一個,評估全部」

這是狀態層的鐵律.

### 原則 2: 換系統 = 換成本模型 → 所有 state 都要重算一次

- 系統的 Compute / Movement Capacity 一變
- DB / Redis / Memory / Client 的成本比就改變
- 原來便宜的做法可能變貴,原來貴的可能變便宜

所以:

一旦換系統 (語言,框架,執行環境),
所有狀態的 PLC 都要在新成本模型下重跑一次.

---

## PLC × Cost × Capacity：決策總表

這張表幫助我們判斷 哪些是合理策略、
哪些是會害死系統的錯誤組合：

| Place | Life | Consistency | 結論 |
|-------|------|-------------|------|
| Client | 長命、重要 | 高一致性 | 錢不能放 Local |
| DB | 短命、頻繁更新 | | DB 被你打爆 |
| Server RAM | 長命、重要 | | 一掛就 RIP（需回寫） |
| Cache | 長命、重要 | | 需設 TTL 與寫回策略 |
| Server RAM | 短命、無價值 | 高一致性 | FPS、格鬥遊戲最佳套路 |

一句話：

活很久 → 不能掉
活很短 → 不要寫 DB
一致性高 → Client 不能當權威

---

## 瓶頸與取捨: 你在做的是什麼?

當系統出現瓶頸時,你現在可以很精準地說:

我不是在「猜」哪裡慢,
我是在用 PLC + Cost + Capacity,
覺得哪些狀態的設定太貴,
可以調整,可以捨棄什麼.

比如:
- 這個狀態真的需要放 DB 嗎? 可以移到 Redis / Memory 嗎? (P)
- 這個資料真的需要秒級一致嗎? 可以變成 1 分鐘一次? (C)
- 這個快取真的要活 1 小時嗎? 10 分鐘就夠了? (L)

每一個調整都會:
- 降低某種 Cost
- 同時影響使用者體驗 / 一致性
- 然後釋放 Capacity 給更重要的狀態用

瓶頸處理 = 用 PLC 找出「可以接受的犧牲」,
讓系統活得久一點,撐得更多.

---

## 使用 AI 輔助決策

感謝你看完上面這麼多表格,我看完眼睛都花了..
而且要填寫這麼多表格也懶得填..
身為有潔癖的工程師,能少寫一行就一行,能永遠不改就不改..XD

因此決定建立一個簡單的 AI 輔助決策工具.

你只要提供:
- 預計要做的功能描述
- 系統的基本架構

AI 會協助你:
- 拆解狀態的 PLC 屬性
- 估算 Compute Cost 和 Movement Cost
- 給出決策建議和調整方案

### 工具說明

> **程式碼待補充**: AI 輔助工具正在開發中,稍後會提供使用方式和程式碼連結.

---


