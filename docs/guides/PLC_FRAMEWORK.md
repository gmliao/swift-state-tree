
# PLC Framework：實務經驗架構分享

最近在做一個 side project（網路狀態同步框架，稍後會開源），
在分析狀態屬性的時候發現狀態好像可以用幾個通用的屬性分類，並且用在效能分析建議上面。
因此整理出這個狀態的評估分析框架，目前是自己的想法，應該有不足或不正確的地方，歡迎大家討論補充。

因此我整理之前的開發經驗，想到其實每天都在做設計狀態同步的事情。

每次設計的時候都會想：

- 這個變數要不要保存？
- 要存在哪裡？
- 更新後要多快讓客戶端知道？

然後發現狀態的屬性選擇是很重要的，
很多效能問題其實不是演算法不夠好，
而是變數保存與同步策略設計錯了。

---

## 以聊天室訊息為例

常見做法是：

每來一則訊息 → 立刻寫入資料庫 → 寫完才通知客戶端

這會導致：

a. 新訊息延遲（等寫入完成才更新 UI）
b. 訊息量大時，DB 被寫爆

然後工程師就開始「靠直覺優化」：

| 策略 | 說法 | 問題 |
|------|------|------|
| a. 不存（逃避雖可恥但有用） | OK 啊都私聊也沒人留存 | 訊息遺失風險 |
| b. 批次/非同步寫入 | UI超順，後台慢慢補 | 當機就 RIP |
| c. 先寫 Cache 再回寫 DB | 性能佳、資料風險可控 | 設計複雜度提高 |

但這邊有個問題：

我們的選擇幾乎都靠經驗與直覺來決定
沒有一個方法能夠系統化地比較、評估與說服他人

尤其在：

- 教新人時：只有講解片段，難以建立全貌
- 與產品與企劃討論時：需要跟他們說他們設計的功能狀態同步消耗太高，但是沒有好的方法

剛好我在分析狀態的時候發現，好像可以整理一個圖表來簡單表示現在的狀態屬性，
然後可以一起討論是否調整狀態的屬性提升系統效能。

---

## 回到根本：什麼是狀態？什麼是系統？

### 1. 狀態（State）

一個當下需要被客戶端知道的資料快照

變了 → 新狀態
必要時 → 要儲存，要同步出去

### 2. 系統（System）

裝狀態的容器，同時也得負責照顧狀態

照顧狀態就會花資源，我們把這叫做 Cost（資源消耗）

分為：

| 種類 | 內容 | 例子 |
|------|------|------|
| 計算消耗 Compute Cost | 狀態變化需要算 | 更新頻率、同步邏輯、序列化、ACL… |
| 移動消耗 Movement Cost | 狀態需要被搬來搬去 | Server→Client、Server→DB、節點同步 |

---

## Capacity（資源上限）

由硬體 + 軟體決定：

- CPU、記憶體、磁碟、網路
- 程式架構、演算法設計

我們的目標很簡單：

不要讓成本超過容量
不然系統就會爆炸

---

## 狀態的三大屬性：PLC 模型

好，現在我們知道系統有 Cost 和 Capacity 的限制了。

那接下來要問的是：**狀態本身有什麼屬性會影響我們的決策？**

我在分析的時候發現，每次做狀態設計決策時，好像都在考慮三個維度：

---

### Place（放置位置）

越靠近客戶端 → 傳輸成本越低
越往後端 → 保存能力越強

| 放置位置 | 優點 | 缺點 |
|---------|------|------|
| Client | 快、成本最低 | 不安全、易消失、可作弊 |
| Server RAM | 快、權威性高 | 重啟就沒了 |
| Cache（Redis） | 多伺服器共享 | 一樣可能掉資料 |
| Database | 最安全、持久化 | 最慢、成本最高 |

---

### Lifetime（狀態生命週期）

兩部分組成：

1. **生命長度** → 這個狀態會存在多久？
   - 例子：玩家位置（很短，遊戲結束就沒了）vs 聊天訊息（永久保存）
   - **注意**：同樣是「玩家位置」，對戰遊戲（很短命）vs MMORPG（需要保存下線位置）屬性不同
   
2. **生命價值** → 過去的狀態是否還有意義？
   - 例子：玩家位置（舊位置沒意義）vs 戰績記錄（歷史很重要）

更新頻率不是生命週期的一部分
它是 Compute Cost 的一部分

例子：

| 狀態 | 遊戲更新頻率 | Web系統更新頻率 | 本質（狀態分類） |
|------|-------------|----------------|-----------------|
| 玩家 HP | 很快 | 偶爾 | HP 狀態仍相同 |
| User Profile | 幾乎不變 | 批次大量更新 | Profile 不會「變別的東西」 |

頻率是場景造成的結果
不是狀態屬性

---

### Consistency（一致性）

狀態變化後，要多快、多準確地讓所有人知道？

分成兩種：

| 類別 | 問題句 | 例子 |
|------|--------|------|
| 時間一致性 Time | 要多久同步？ | 延遲超過 100ms 就被罵 |
| 數值一致性 Value | 能不能短暫錯？ | 玩家位置差 1-2 像素 OK，之後會校正 |

---

## 實際案例：用 PLC 三軸定位

好，現在我們有了 PLC 三個維度了。

讓我們用實際案例來看看，這三個維度如何幫助我們做決策：

### 案例 1：玩家位置

| 維度 | 分析 | 說明 |
|------|------|------|
| **Place** | Server RAM（客戶端預測可參考） | 需要權威性，但可以讓客戶端先預測 |
| **Life** | 很短、舊值沒意義 | 只對「現在」有意義，過去的位置沒用 |
| **Time Consistency** | 超高（>100ms 就穿牆） | 不能延遲，否則會看到玩家穿牆 |
| **Value Consistency** | 偏高（但可容忍少量誤差後再修正） | 位置可以局部校正，不需要完全精確 |

**結論**：只存 Server RAM，不同步到 DB，但同步要很快。

---

### 案例 2：玩家 HP

| 維度 | 分析 | 說明 |
|------|------|------|
| **Place** | Server + Cache | 需要權威性，但也要能快速讀取 |
| **Life** | 中等生命價值（戰鬥結束後還要用） | 戰鬥結束後還需要記錄最終血量 |
| **Time Consistency** | 中～高（延遲太久會被罵，但不需要逐毫秒） | 不需要最即時，但也不能太慢 |
| **Value Consistency** | 極高（錯 1 點血都會出事） | 必須非常準確，不能有誤差 |

**結論**：不需要最即時，但要非常準確，戰鬥結束後要保存。

---

### 案例 3：聊天室訊息

| 維度 | 分析 | 說明 |
|------|------|------|
| **Place** | Cache + DB | 要快也要保存 |
| **Life** | 長期保存很重要 | 歷史訊息很重要，要永久保存 |
| **Time Consistency** | 中（晚一點沒差） | 晚個幾秒沒關係 |
| **Value Consistency** | 高（訊息不能亂） | 訊息順序和內容不能錯 |

**結論**：既要保存，也不必超低延遲，可以用非同步寫入。

---

### 案例 4：購物車內容

| 維度 | 分析 | 說明 |
|------|------|------|
| **Place** | Client + Server | 客戶端先顯示，伺服器備份 |
| **Life** | 活中等（斷線不能不見） | 斷線不能不見，但不需要永久保存 |
| **Time Consistency** | 低～中（晚個幾秒沒人發現） | 晚個幾秒沒關係 |
| **Value Consistency** | 高（少一件商品=世界末日） | 商品數量必須準確 |

**結論**：使用者體驗比同步速度重要，但要確保資料不遺失。

---

### 案例 5：JWT Token

| 維度 | 分析 | 說明 |
|------|------|------|
| **Place** | Client 為主 | 主要存在客戶端，減少伺服器負擔 |
| **Life** | 重要但可再發行 | 重要但過期可以重新簽發 |
| **Time Consistency** | 低 | 不需要即時同步 |
| **Value Consistency** | 中（過期也可以重新簽） | 可以容忍過期，重新簽發就好 |

**結論**：主要放客戶端，過期就重新簽發。


---

## 用 PLC 框架做決策討論

有了上面的狀態案例，我們可以針對狀態案例來分析討論。

因為屬性是可以調整的，調整屬性有可能改變消耗。

不過改變屬性應該是產品設計師與工程師一起討論，都是一種 trade off。

### 調整屬性的權衡

譬如：

- **降低一致性**：可以降低消耗，但是可能會讓時間一致性變低，是否可接受？
- **改變位置**：可以降低消耗，但是可能會導致資料不一致，是否可接受？
- **改變生命週期**：可以降低儲存成本，但是可能會遺失重要資料，是否可接受？

### 發現不合理的設計

另一方面，PLC 框架也可以用來討論目前的狀態設計也許不合理。

譬如：

- **Place 不合理**：Session 的 Place 在 DB，每個請求都必須查詢 DB
  → 問題：Session 是短期的，不需要持久化，應該放 Cache 或 Server RAM
  
- **Lifetime 不合理**：對戰遊戲的玩家位置（很短命，遊戲結束就沒了）卻寫入資料庫永久保存
  → 問題：對戰遊戲的位置是短命的，不需要永久保存，浪費儲存空間和寫入成本
  → 注意：MMORPG 的玩家位置可能需要保存（下線位置、傳送點），所以要看遊戲類型
  
- **Consistency 不合理**：聊天訊息設計成時間一致性很高（毫秒級）
  → 問題：聊天訊息不需要毫秒級同步，晚個幾秒沒關係，可以降低系統負擔

**重點**：同樣的狀態（如「位置」），在不同的應用場景下，PLC 屬性會不同。設計時要根據實際場景來決定屬性。

        



---

## PLC × Cost × Capacity：決策總表

這張表幫助我們判斷 哪些是合理策略、
哪些是會害死系統的錯誤組合：

| Place | Life | Consistency | 結論 |
|-------|------|-------------|------|
| Client | 長命、重要 | 高一致性 | 錢不能放 Local |
| DB | 短命、頻繁更新 | | DB 被你打爆 |
| Server RAM | 長命、重要 | | 一掛就 RIP（需回寫） |
| Cache | 長命、重要 | | 需設 TTL 與寫回策略 |
| Server RAM | 短命、無價值 | 高一致性 | FPS、格鬥遊戲最佳套路 |

一句話：

活很久 → 不能掉
活很短 → 不要寫 DB
一致性高 → Client 不能當權威

---

下一步就是把 PLC 和 Cost 做一個表格，方便分析


