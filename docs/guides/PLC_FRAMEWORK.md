
📌PLC Framework：實務經驗架構分享

最近在做一個side project-網路狀態同步框架(稍後會開源)，
在分析狀態屬性的時候發現狀態的好像可以用幾個通用的屬性分類並且用在效能分析建議上面.
因此整理出這個狀態的評估分析框架,目前是自己的想法應該有不足會不正確的地方歡迎大家討論補充.

引此我整理之前跟之前的開發經驗做連結,想到其實每天都在做設計狀態同步狀態的事情.

每次設計的時候都會想：

- 這個變數要不要保存？
- 要存在哪裡？
- 更新後要多快讓客戶端知道？

然後發現狀態的屬性選擇是很重要的,
很多效能問題其實不是演算法不夠好，
而是變數保存與同步策略設計錯了。


🗨️ 以聊天室訊息為例

常見做法是：

每來一則訊息 → 立刻寫入資料庫 → 寫完才通知客戶端

這會導致：

a. 新訊息延遲（等寫入完成才更新 UI）
b. 訊息量大時，DB 被寫爆

然後工程師就開始「靠直覺優化」：

| 策略 | 說法 | 問題 |
|------|------|------|
| a. 不存（逃避雖可恥但有用） | OK 啊都私聊也沒人留存 | 訊息遺失風險 |
| b. 批次/非同步寫入 | UI超順，後台慢慢補 | 當機就 RIP |
| c. 先寫 Cache 再回寫 DB | 性能佳、資料風險可控 | 設計複雜度提高 |

但這邊有個問題：

我們的選擇幾乎都靠經驗與直覺來決定
沒有一個方法能夠系統化地比較、評估與說服他人

尤其在：

- 教新人時：只有講解片段，難以建立全貌
- 與產品與企劃討論時：會要跟他們說他們設計的功能狀態同步消耗太高.但是沒有好的方法.

剛好我在分析狀態的時候發現好像可以整理一個圖表簡單表示現在的狀態屬性.
然後可以一起討論是否調整狀態的屬性提升系統效能.

---

🧩 回到根本：什麼是狀態？什麼是系統？

1️⃣ 狀態（State）

一個當下需要被客戶端知道的資料快照

變了 → 新狀態
必要時 → 要儲存，要同步出去

2️⃣ 系統（System）

裝狀態的容器，同時也得負責照顧狀態

照顧狀態就會花資源我們把這叫做 Cost（資源消耗）

分為：

| 種類 | 內容 | 例子 |
|------|------|------|
| 計算消耗 Compute Cost | 狀態變化需要算 | 更新頻率、同步邏輯、序列化、ACL… |
| 移動消耗 Movement Cost | 狀態需要被搬來搬去 | Server→Client、Server→DB、節點同步 |

---


🧱 Capacity（資源上限）

由硬體 + 軟體決定：

- CPU、記憶體、磁碟、網路
- 程式架構、演算法設計

我們的目標很簡單：

不要讓成本超過容量
不然系統就會爆炸

---

🔎 狀態的三大屬性：PLC 模型

定義好環境後，我們可以來分析 狀態本身的策略屬性：

---

(a) Place（放置位置）

越靠近客戶端 → 傳輸成本越低
越往後端 → 保存能力越強

| 放置位置 | 優點 | 缺點 |
|---------|------|------|
| Client | 快、成本最低 | 不安全、易消失、可作弊 |
| Server RAM | 快、權威性高 | 重啟就沒了 |
| Cache（Redis） | 多伺服器共享 | 一樣可能掉資料 |
| Database | 最安全、持久化 | 最慢、成本最高 |

---


(b) Life（狀態生命週期）

兩部分組成：

1️⃣ 生命長度 → 這個狀態會存在多久？
2️⃣ 生命價值 → 過去的狀態是否還有意義？

更新頻率不是生命週期的一部分
它是 Compute Cost 的一部分

例子：

| 狀態 | 遊戲更新頻率 | Web系統更新頻率 | 本質（狀態分類） |
|------|-------------|----------------|-----------------|
| 玩家 HP | 很快 | 偶爾 | HP 狀態仍相同 |
| User Profile | 幾乎不變 | 批次大量更新 | Profile 不會「變別的東西」 |

頻率是場景造成的結果
不是狀態屬性

---


(c) Consistency（一致性）

狀態變化後，要多快、多準確地讓所有人知道？

分成兩種：

| 類別 | 問題句 | 例子 |
|------|--------|------|
| 時間一致性 Time | 要多久同步？ | 延遲超過 100ms 就被罵 |
| 數值一致性 Value | 能不能短暫錯？ | 血量顯示-1~1 OK 吧 |

---


📍 實際案例：三軸定位

| 狀態例子 | Place（放哪） | Life（活多久、有沒有價值） | Time Consistency（要多快通知） | Value Consistency（可不可以有誤差） | 說明與原因 |
|---------|--------------|---------------------------|------------------------------|-----------------------------------|-----------|
| 玩家位置 | Server RAM（客戶端預測可參考） | 很短、舊值沒意義 | 超高（>100ms就穿牆） | 偏高（但可容忍少量誤差後再修正） | 只對「現在」有意義，不能延遲，但位置可局部校正 |
| 玩家 HP | Server + Cache | 中等生命價值（戰鬥結束後還要用） | 中～高（滯後會吵，但不需要逐毫秒） | 極高（錯1點血都會出事 🤣） | 不需要最即時，但要非常準確 |
| 聊天室訊息 | Cache + DB | 長期保存很重要 | 中（晚一點沒差） | 高（訊息不能亂） | 既要保存，也不必超低延遲 |
| 購物車內容 | Client + Server | 活中等（斷線不能不見） | 低～中（晚個幾秒沒人發現） | 高（少一件商品=世界末日） | 使用者體驗＞同步速度 |
| JWT Token | Client 為主 | 重要但可再發行 | 低 | 中（過期也可以重新簽） | |



工程師看到這張表就懂：
沒有最佳答案，只有最適合的設計。

---

🚦 PLC × Cost × Capacity：決策總表

這張表幫助我們判斷 哪些是合理策略、
哪些是會害死系統的錯誤組合：

| Place | Life | Consistency | 結論 |
|-------|------|-------------|------|
| Client | 長命、重要|高一致性 | ❌ 錢不能放 Local |
| DB | 短命頻繁更新|  | ❌ DB 被你打爆 |
| Server RAM | 長命、重要 | | ⚠️ 一掛就 RIP（需回寫） |
| Cache | 長命、重要 | | ⚠️ 需設 TTL 與寫回策略 |
| Server RAM | 短命、無價值|高一致性  | ✔️ FPS、格鬥遊戲最佳套路 |

一句話：

活很久 → 不能掉
活很短 → 不要寫 DB
一致性高 → Client 不能當權威

---

下一步就是把PLC跟Cost做一個表格方便分析


