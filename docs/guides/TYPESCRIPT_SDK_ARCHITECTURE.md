# TypeScript SDK 架構設計

> 本文檔整合了 TypeScript SDK 的完整架構設計，包括核心客戶端、Code-gen 機制、以及與 Playground/CLI 的整合方案。

## 目錄

1. [設計理念](#設計理念)
2. [架構總覽](#架構總覽)
3. [核心組件](#核心組件)
4. [Code-gen 機制](#code-gen-機制)
5. [整合方案](#整合方案)
6. [實作計劃](#實作計劃)

## 設計理念

### 為什麼需要 TypeScript SDK？

1. **型別安全**：從 Server 定義自動生成，確保型別完全一致
2. **自動同步**：Server 定義變更時，客戶端 SDK 自動更新
3. **減少錯誤**：避免手動定義導致的型別不匹配
4. **開發體驗**：提供完整的 TypeScript 型別提示和自動完成

### 核心原則

- **單一來源真相（Single Source of Truth）**：Server 定義是權威來源
- **自動生成優先**：型別定義必須從 Schema 自動生成，不支援手動定義
- **協議層與應用層分離**：核心協議處理與型別安全的 API 分層設計

## 架構總覽

```
┌─────────────────────────────────────────────────────────────┐
│                    Server (Swift)                            │
│  LandDefinition → Schema Generator → schema.json            │
└──────────────────────┬──────────────────────────────────────┘
                       │
                       ↓
┌─────────────────────────────────────────────────────────────┐
│              Code-gen Script (gen-schema.ts)                 │
│  schema.json → Generated Types & Constants                   │
└──────────────────────┬──────────────────────────────────────┘
                       │
                       ↓
┌─────────────────────────────────────────────────────────────┐
│              SDK Core (src/core/)                            │
│  StateTreeRuntime - 底層連線管理                            │
│  - WebSocket 連接管理                                        │
│  - Protocol 編碼/解碼                                        │
│  - 訊息路由                                                  │
│                                                              │
│  StateTreeView - StateTree 視圖                              │
│  - 狀態同步（Snapshot/Update/Patch）                        │
│  - Action/Event 基礎處理                                     │
│  - 狀態查詢                                                  │
└──────────────────────┬──────────────────────────────────────┘
                       │
                       ↓
┌─────────────────────────────────────────────────────────────┐
│         Type-Safe API (src/api/actions.ts)                   │
│  基於 Generated Types 的型別安全方法                        │
│  - sendAction<'AddGold'>(payload: AddGoldAction)            │
│  - onEvent<'ChatMessage'>(handler: Handler)                │
└──────────────────────┬──────────────────────────────────────┘
                       │
                       ↓
┌─────────────────────────────────────────────────────────────┐
│              Applications                                    │
│  - Playground (Vue 3 UI)                                    │
│  - CLI (Node.js CLI Tool)                                   │
│  - 第三方應用（使用 npm 包）                                │
└─────────────────────────────────────────────────────────────┘
```

## 核心組件

### 1. Schema Generator（Server 端）

**位置**：`Sources/SwiftStateTree/SchemaGen/`

**職責**：
- 從 `LandDefinition` 提取型別資訊
- 生成 JSON Schema（`schema.json`）
- 提供 `/schema` HTTP 端點

**輸出格式**：`ProtocolSchema`（見 `docs/protocol/SCHEMA_DEFINITION.md`）

```json
{
  "version": "0.1.0",
  "lands": {
    "demo-game": {
      "stateType": "DemoGameState",
      "actions": { "AddGold": { "$ref": "#/defs/AddGoldAction" } },
      "clientEvents": { "Chat": { "$ref": "#/defs/ChatEvent" } },
      "events": { "ChatMessage": { "$ref": "#/defs/ChatMessageEvent" } }
    }
  },
  "defs": {
    "AddGoldAction": { "type": "object", "properties": { ... } },
    "ChatEvent": { "type": "object", "properties": { ... } }
  }
}
```

### 2. Code-gen Script（TypeScript）

**位置**：`scripts/gen-schema.ts`（待創建）

**職責**：
- 讀取 `schema.json`
- 生成 TypeScript 型別定義
- 生成常數定義
- 生成型別安全的 API 方法（可選）

**生成內容**：

#### a. 型別定義 (`generated/types.ts`)

```typescript
// AUTOGENERATED - DO NOT EDIT
// Generated from schema.json version 0.1.0

export interface AddGoldAction {
  amount: number
}

export interface AddGoldResponse {
  success: boolean
  newGold: number
  newLevel: number
}

export interface ChatEvent {
  message: string
}

export interface ChatMessageEvent {
  message: string
  from: string
}

// ... 更多型別
```

#### b. 常數定義 (`generated/land-constants.ts`)

```typescript
// AUTOGENERATED - DO NOT EDIT
// Generated from schema.json version 0.1.0

export const SCHEMA_VERSION = '0.1.0'

export const LAND_IDS = {
  DEMO_GAME: 'demo-game'
} as const

export type LandId = typeof LAND_IDS[keyof typeof LAND_IDS]

export type ActionId = 
  | 'AddGold'
  | 'GetMyPrivateState'
  | 'UpdateScore'
  | 'UpdateSettings'

export type ClientEventId = 
  | 'Chat'
  | 'Ping'

export type ServerEventId = 
  | 'ChatMessage'
  | 'Pong'

// Action ID 到型別的映射
export const ACTION_TYPES: Record<ActionId, string> = {
  AddGold: 'AddGoldAction',
  GetMyPrivateState: 'GetMyPrivateStateAction',
  UpdateScore: 'UpdateScoreAction',
  UpdateSettings: 'UpdateSettingsAction'
} as const

// Event ID 到型別的映射
export const CLIENT_EVENT_TYPES: Record<ClientEventId, string> = {
  Chat: 'ChatEvent',
  Ping: 'PingEvent'
} as const

export const SERVER_EVENT_TYPES: Record<ServerEventId, string> = {
  ChatMessage: 'ChatMessageEvent',
  Pong: 'PongEvent'
} as const
```

#### c. 型別安全的 API（可選，`src/api/generated.ts`）

```typescript
// AUTOGENERATED - DO NOT EDIT
// Generated from schema.json version 0.1.0

import { StateTreeRuntime, StateTreeView } from '../core'
import type {
  AddGoldAction,
  AddGoldResponse,
  GetMyPrivateStateAction,
  PlayerPrivateStateResponse,
  ChatEvent,
  ChatMessageEvent
} from '../generated/types'
import type { ActionId, ClientEventId, ServerEventId } from '../generated/land-constants'

export class StateTreeClient {
  private view: StateTreeView
  
  constructor(runtime: StateTreeRuntime, landID: string) {
    this.view = runtime.createView(landID)
  }
  // 型別安全的 Action 方法
  async addGold(payload: AddGoldAction): Promise<AddGoldResponse> {
    return this.view.sendAction('AddGold', payload)
  }
  
  async getMyPrivateState(): Promise<PlayerPrivateStateResponse> {
    return this.view.sendAction('GetMyPrivateState', {})
  }
  
  async updateScore(score: number): Promise<void> {
    return this.view.sendAction('UpdateScore', { score })
  }
  
  // 型別安全的 Event 發送
  sendChatEvent(payload: ChatEvent): void {
    this.view.sendEvent('Chat', payload)
  }
  
  sendPingEvent(): void {
    this.view.sendEvent('Ping', {})
  }
  
  // 型別安全的 Event 訂閱
  onChatMessage(handler: (event: ChatMessageEvent) => void): () => void {
    return this.view.onServerEvent('ChatMessage', handler)
  }
  
  onPong(handler: () => void): () => void {
    return this.view.onServerEvent('Pong', handler)
  }
}
```

### 3. SDK Core（協議層）

**位置**：`SDK/ts/src/core/`（從 `Examples/CLI/src/client.ts` 提取並重構）

**架構設計**：
- **Runtime**：底層連線管理，處理 WebSocket 連接和協議層訊息
- **View**：StateTree 視圖，管理特定 land 的狀態同步和 Action/Event

**核心類別**：

#### a. `StateTreeRuntime`（底層連線管理）

```typescript
export class StateTreeRuntime {
  private ws: WebSocket | null = null
  private isConnected = false
  private views = new Map<LandID, StateTreeView>()
  
  // 連接管理
  async connect(url: string): Promise<void>
  disconnect(): void
  
  // 創建 View（對應一個 land/StateTree）
  createView(landID: LandID, options?: ViewOptions): StateTreeView
  
  // 內部：訊息路由
  private routeMessage(message: TransportMessage): void
}
```

**職責**：
- WebSocket 連接管理（支援瀏覽器和 Node.js）
- Protocol 訊息編碼/解碼（正確的 MessagePayload 格式）
- 訊息路由到對應的 View
- 連接生命週期管理

#### b. `StateTreeView`（StateTree 視圖）

```typescript
export class StateTreeView {
  private landID: LandID
  private currentState: Record<string, any> = {}
  private actionCallbacks = new Map<string, Callback>()
  
  constructor(
    private runtime: StateTreeRuntime,
    landID: LandID,
    options?: ViewOptions
  ) {}
  
  // Join 流程（連接到這個 land）
  async join(): Promise<{ success: boolean; playerID?: string; reason?: string }>
  
  // Action 處理（基礎方法，型別為 any）
  async sendAction(actionType: string, payload: any): Promise<any>
  
  // Event 處理（基礎方法，型別為 any）
  sendEvent(eventType: string, payload: any): void
  onServerEvent(eventType: string, handler: (payload: any) => void): () => void
  
  // 狀態查詢
  getState(): Record<string, any>
  
  // 銷毀視圖
  destroy(): void
}
```

**職責**：
- 狀態同步處理（Snapshot、StateUpdate、Patch）
- Action/Event 基礎處理
- 狀態查詢
- 錯誤處理和回調管理

**關鍵特性**：
- ✅ 正確的 MessagePayload 編碼格式（`{ action: {...} }`, `{ joinResponse: {...} }` 等）
- ✅ 完整的 SnapshotValue 解碼（`type + value` 格式）
- ✅ 狀態 Patch 應用邏輯
- ✅ 錯誤處理和回調管理
- ✅ 語義清晰：View 表示「查看 StateTree 的視圖」

**架構圖**：

```
┌─────────────────────────────────────────┐
│         StateTreeRuntime                 │
│  - WebSocket 連接管理                    │
│  - 訊息路由                              │
│  - 連接生命週期                          │
└──────────────┬──────────────────────────┘
               │
       ┌───────┴────────┐
       │                │
┌──────▼──────┐  ┌──────▼──────┐
│  View (Lobby)│  │ View (Game) │
│  - landID    │  │ - landID    │
│  - state     │  │ - state     │
│  - actions   │  │ - actions   │
└──────────────┘  └─────────────┘
```

**使用範例**：

```typescript
// 創建 Runtime（單一連接）
const runtime = new StateTreeRuntime()
await runtime.connect('ws://localhost:8080/game')

// 創建多個 View（查看不同的 land）
const lobbyView = runtime.createView('lobby-asia')
await lobbyView.join()

const gameView = runtime.createView('battle-royale-123')
await gameView.join()

// 每個 View 獨立操作
await lobbyView.sendAction('RequestMatchmaking', { ... })
await gameView.sendAction('Attack', { ... })

// 查看各自的狀態
const lobbyState = lobbyView.getState()
const gameState = gameView.getState()
```

**設計優勢**：
1. **語義清晰**：`View` 明確表示「查看 StateTree 的視圖」，比 `Client` 更準確
2. **分層明確**：`Runtime`（協議層）vs `View`（視圖層）
3. **擴展性好**：未來可支持一個 Runtime 多個 View（多 land 連接）
4. **符合概念**：每個客戶端確實是在「查看」StateTree 的一個視圖

### 4. Type-Safe API 層（應用層）

**位置**：`SDK/ts/src/api/generated.ts`（Code-gen 生成）或 `SDK/ts/src/api/manual.ts`（手寫）

**職責**：
- 提供型別安全的 Action/Event 方法
- 基於 Generated Types 確保編譯時型別檢查
- 使用 TypeScript 泛型和條件型別

**設計模式**：

```typescript
// 使用泛型確保型別安全
async sendAction<T extends ActionId>(
  actionId: T,
  payload: ActionPayloadMap[T]
): Promise<ActionResponseMap[T]>

// 使用條件型別映射
type ActionPayloadMap = {
  AddGold: AddGoldAction
  GetMyPrivateState: GetMyPrivateStateAction
  // ...
}

type ActionResponseMap = {
  AddGold: AddGoldResponse
  GetMyPrivateState: PlayerPrivateStateResponse
  // ...
}
```

## Code-gen 機制

### 工作流程

```
1. Server 啟動時生成 schema.json
   ↓
2. 開發者運行 code-gen 腳本
   node scripts/gen-schema.ts
   ↓
3. 生成 generated/ 目錄
   - types.ts
   - land-constants.ts
   - validators.ts (可選)
   ↓
4. SDK 核心使用生成的型別
   ↓
5. 應用層使用型別安全的 API
```

### Code-gen 腳本結構

```typescript
// scripts/gen-schema.ts
import { readFileSync, writeFileSync, mkdirSync } from 'fs'
import { join } from 'path'
import type { ProtocolSchema } from '../SDK/ts/src/types/schema'

interface CodegenConfig {
  schemaPath: string
  outputDir: string
  generateValidators?: boolean
}

async function generateTypeScriptSDK(config: CodegenConfig) {
  // 1. 讀取 schema
  const schema: ProtocolSchema = JSON.parse(
    readFileSync(config.schemaPath, 'utf-8')
  )
  
  // 2. 確保輸出目錄存在
  mkdirSync(config.outputDir, { recursive: true })
  mkdirSync(join(config.outputDir, 'generated'), { recursive: true })
  
  // 3. 生成型別定義
  const typesCode = generateTypes(schema.defs)
  writeFileSync(
    join(config.outputDir, 'generated/types.ts'),
    typesCode
  )
  
  // 4. 生成常數定義
  const constantsCode = generateConstants(schema)
  writeFileSync(
    join(config.outputDir, 'generated/land-constants.ts'),
    constantsCode
  )
  
  // 5. 生成型別安全的 API（可選）
  const apiCode = generateAPI(schema)
  writeFileSync(
    join(config.outputDir, 'src/api/generated.ts'),
    apiCode
  )
  
  // 6. 生成 Zod validators（可選）
  if (config.generateValidators) {
    const validatorsCode = generateValidators(schema.defs)
    writeFileSync(
      join(config.outputDir, 'generated/validators.ts'),
      validatorsCode
    )
  }
  
  console.log(`✅ TypeScript SDK generated from schema ${schema.version}`)
}

// 主函數
const schemaPath = process.argv[2] || 'Examples/HummingbirdDemo/schema.json'
const outputDir = process.argv[3] || 'SDK/ts'

generateTypeScriptSDK({
  schemaPath,
  outputDir,
  generateValidators: true
}).catch(console.error)
```

### 生成函數範例

```typescript
function generateTypes(defs: Record<string, JSONSchema>): string {
  const lines: string[] = []
  lines.push('// AUTOGENERATED - DO NOT EDIT')
  lines.push(`// Generated from schema.json`)
  lines.push('')
  
  for (const [name, schema] of Object.entries(defs)) {
    if (schema.type === 'object' && schema.properties) {
      lines.push(`export interface ${name} {`)
      for (const [propName, propSchema] of Object.entries(schema.properties)) {
        const optional = schema.required?.includes(propName) ? '' : '?'
        const type = jsonSchemaToTypeScript(propSchema)
        lines.push(`  ${propName}${optional}: ${type}`)
      }
      lines.push('}')
      lines.push('')
    }
  }
  
  return lines.join('\n')
}

function generateConstants(schema: ProtocolSchema): string {
  const lines: string[] = []
  lines.push('// AUTOGENERATED - DO NOT EDIT')
  lines.push(`// Generated from schema.json version ${schema.version}`)
  lines.push('')
  lines.push(`export const SCHEMA_VERSION = '${schema.version}'`)
  lines.push('')
  
  // 生成 Land IDs
  const landIds = Object.keys(schema.lands)
  lines.push('export const LAND_IDS = {')
  for (const landId of landIds) {
    const constName = landId.toUpperCase().replace(/-/g, '_')
    lines.push(`  ${constName}: '${landId}',`)
  }
  lines.push('} as const')
  lines.push('')
  lines.push(`export type LandId = typeof LAND_IDS[keyof typeof LAND_IDS]`)
  lines.push('')
  
  // 生成 Action IDs
  const actionIds = new Set<string>()
  for (const land of Object.values(schema.lands)) {
    if (land.actions) {
      for (const actionId of Object.keys(land.actions)) {
        actionIds.add(actionId)
      }
    }
  }
  lines.push(`export type ActionId =`)
  lines.push(`  | '${Array.from(actionIds).join("'\n  | '")}'`)
  lines.push('')
  
  // 類似地生成 ClientEventId 和 ServerEventId
  // ...
  
  return lines.join('\n')
}
```

## 整合方案

### 1. CLI 核心提取為 SDK 核心

**當前狀態**：
- `Examples/CLI/src/client.ts` 包含完整的協議處理邏輯
- 使用正確的 MessagePayload 格式
- 完整的狀態同步處理

**提取步驟**：

1. **創建 SDK 目錄結構**：
```
SDK/ts/
├── generated/          # Code-gen 生成（git ignored 或 committed）
│   ├── types.ts
│   ├── land-constants.ts
│   └── validators.ts
├── src/
│   ├── core/            # 核心協議層（從 CLI 提取）
│   │   ├── client.ts     # SwiftStateTreeClient
│   │   ├── protocol.ts   # Protocol 編碼/解碼
│   │   ├── state.ts      # 狀態管理
│   │   └── websocket.ts # WebSocket 抽象層
│   ├── api/             # 型別安全的 API
│   │   ├── generated.ts # Code-gen 生成
│   │   └── manual.ts    # 手寫擴展（可選）
│   ├── types/           # 型別定義
│   │   ├── schema.ts    # Schema 型別
│   │   └── transport.ts # Transport 協議型別
│   └── index.ts         # Public API
├── package.json
└── tsconfig.json
```

2. **抽象 WebSocket 連接層**：
```typescript
// src/core/websocket.ts
export interface WebSocketConnection {
  send(data: string | ArrayBuffer): void
  close(): void
  onopen: ((event: Event) => void) | null
  onclose: ((event: CloseEvent) => void) | null
  onerror: ((event: Event) => void) | null
  onmessage: ((event: MessageEvent) => void) | null
  readyState: number
}

// 瀏覽器實現
export class BrowserWebSocket implements WebSocketConnection {
  constructor(private ws: globalThis.WebSocket) {}
  // ...
}

// Node.js 實現
export class NodeWebSocket implements WebSocketConnection {
  constructor(private ws: WebSocket) {}
  // ...
}
```

3. **提取核心客戶端**：
- 將 `Examples/CLI/src/client.ts` 的邏輯移到 `SDK/ts/src/core/client.ts`
- 使用抽象的 `WebSocketConnection` 介面
- 保持所有協議處理邏輯不變

### 2. Playground 整合

**當前問題**：
- Playground 使用錯誤的 MessagePayload 格式（直接 payload，沒有包裝）
- 型別定義與實際協議不匹配

**修正方案**：

1. **使用 SDK 核心**：
```typescript
// Examples/Playground/src/composables/useWebSocket.ts
import { StateTreeRuntime, StateTreeView } from '@swiftstatetree/sdk/core'
import { BrowserWebSocket } from '@swiftstatetree/sdk/core/websocket'

// 創建 Runtime（底層連線）
const runtime = new StateTreeRuntime()
await runtime.connect(url)

// 創建 View（StateTree 視圖）
const view = runtime.createView(landID)
await view.join()
```

2. **使用生成的型別**：
```typescript
import type { AddGoldAction, AddGoldResponse } from '@swiftstatetree/sdk/generated/types'
import { LAND_IDS, ActionId } from '@swiftstatetree/sdk/generated/land-constants'
```

3. **修正協議格式**：
- 移除 Playground 中錯誤的 payload 格式
- 使用 SDK 核心的正確格式

### 3. CLI 使用 SDK

**重構 CLI**：
```typescript
// Examples/CLI/src/cli.ts
import { StateTreeRuntime, StateTreeView } from '@swiftstatetree/sdk/core'
import { NodeWebSocket } from '@swiftstatetree/sdk/core/websocket'
import type { ActionId } from '@swiftstatetree/sdk/generated/land-constants'

// CLI 使用 SDK 核心，而不是自己的實現
const runtime = new StateTreeRuntime()
await runtime.connect(url)
const view = runtime.createView(landID)
await view.join()
```

## 實作計劃

### Phase 1: 核心提取（優先）

1. ✅ 創建 `SDK/ts/` 目錄結構
2. ✅ 抽象 WebSocket 連接層
3. ✅ 重構為 `StateTreeRuntime` + `StateTreeView` 架構
4. ✅ 提取到 `SDK/ts/src/core/runtime.ts` 和 `SDK/ts/src/core/view.ts`
5. ✅ 統一型別定義到 `SDK/ts/src/types/`
6. ✅ 更新 CLI 使用 SDK 核心

### Phase 2: Code-gen 實作

1. ✅ 創建 `scripts/gen-schema.ts`
2. ✅ 實作型別生成（`generateTypes`）
3. ✅ 實作常數生成（`generateConstants`）
4. ✅ 可選：實作 API 生成（`generateAPI`）
5. ✅ 可選：實作 Zod validators 生成

### Phase 3: Playground 整合

1. ✅ 更新 Playground 使用 SDK 核心
2. ✅ 修正 Playground 的協議格式
3. ✅ 使用生成的型別確保型別安全
4. ✅ 測試整合

### Phase 4: 文檔與發布

1. ✅ 更新 SDK 使用文檔
2. ✅ 創建 npm 包配置
3. ✅ 設置 CI/CD 自動生成
4. ✅ 發布到 npm

## 目錄結構（最終）

```
swift-state-tree-internal/
├── Sources/                    # Swift 核心庫
├── Examples/
│   ├── HummingbirdDemo/       # Server 範例
│   ├── Playground/            # Vue 3 UI（使用 SDK）
│   └── CLI/                   # CLI 工具（使用 SDK）
├── SDK/
│   └── ts/                    # TypeScript SDK
│       ├── generated/         # Code-gen 生成
│       │   ├── types.ts
│       │   ├── land-constants.ts
│       │   └── validators.ts
│       ├── src/
│       │   ├── core/          # 核心協議層
│       │   │   ├── runtime.ts # StateTreeRuntime
│       │   │   ├── view.ts    # StateTreeView
│       │   │   ├── protocol.ts # Protocol 編碼/解碼
│       │   │   ├── state.ts   # 狀態管理
│       │   │   └── websocket.ts # WebSocket 抽象層
│       │   ├── api/           # 型別安全 API
│       │   └── types/         # 型別定義
│       ├── package.json
│       └── tsconfig.json
├── scripts/
│   └── gen-schema.ts          # Code-gen 腳本
└── docs/
    └── guides/
        └── TYPESCRIPT_SDK_ARCHITECTURE.md  # 本文檔
```

## 關鍵設計決策

### 1. 協議層與應用層分離

- **協議層**（`core/runtime.ts` + `core/view.ts`）：處理所有協議細節，型別為 `any`
  - `Runtime`：底層連線管理和訊息路由
  - `View`：StateTree 視圖和狀態同步
- **應用層**（`api/generated.ts`）：提供型別安全的 API，基於生成的型別

### 2. Code-gen 生成內容

- **必須生成**：型別定義、常數定義
- **可選生成**：型別安全的 API 方法、Zod validators

### 3. WebSocket 抽象

- 支援瀏覽器（`globalThis.WebSocket`）和 Node.js（`ws` 包）
- 通過介面抽象，核心邏輯不依賴具體實現

### 4. 版本管理

- Schema 版本與 SDK 版本同步
- 在生成的代碼中包含 `SCHEMA_VERSION` 常數
- 客戶端可以在連接時報告使用的 Schema 版本

## 與現有實現的關係

### CLI 核心 → SDK 核心

`Examples/CLI/src/client.ts` 中的 `SwiftStateTreeClient` 類別將重構為 SDK 的核心架構：

- ✅ **協議格式正確**：使用正確的 MessagePayload 編碼格式
- ✅ **功能完整**：包含所有必要的協議處理邏輯
- ✅ **狀態同步**：完整的 Snapshot/Update/Patch 處理
- ✅ **錯誤處理**：統一的錯誤處理機制
- ✅ **架構清晰**：分離為 `Runtime`（連線管理）和 `View`（視圖管理）

### Playground 整合

`Examples/Playground/src/composables/useWebSocket.ts` 需要：

- ❌ **修正協議格式**：目前使用錯誤的 payload 格式
- ✅ **使用 SDK 核心**：改用 SDK 的 `StateTreeRuntime` + `StateTreeView`
- ✅ **使用生成型別**：確保型別安全

### Code-gen 輸出

從 `schema.json` 生成：

1. **型別定義**：所有 Action、Event、Response 的 TypeScript 介面
2. **常數定義**：Land ID、Action ID、Event ID 的常數和 union types
3. **型別映射**：Action ID → Action Type 的映射表
4. **可選 API**：型別安全的 `sendAction` 和 `onEvent` 方法

## 總結

### 核心要點

1. **CLI 核心 = SDK 核心基礎**
   - `Examples/CLI/src/client.ts` 的 `SwiftStateTreeClient` 將重構為 `StateTreeRuntime` + `StateTreeView`
   - `Runtime`：底層連線管理和協議處理
   - `View`：StateTree 視圖、狀態同步和 Action/Event 處理
   - 使用正確的 MessagePayload 格式
   - 包含完整的狀態同步和錯誤處理

2. **Code-gen 生成型別和常數**
   - 從 `schema.json` 生成 TypeScript 型別定義
   - 生成 Land/Action/Event 常數和 union types
   - 可選生成型別安全的 API 方法

3. **協議層與應用層分離**
   - 協議層（`core/runtime.ts` + `core/view.ts`）：處理所有協議細節，型別為 `any`
     - `Runtime`：WebSocket 連接、協議編碼/解碼、訊息路由
     - `View`：狀態同步、Action/Event 處理、狀態查詢
   - 應用層（`api/generated.ts`）：提供型別安全的 API，基於生成的型別

4. **整合 Playground 和 CLI**
   - Playground 需要修正協議格式並使用 SDK 核心（`Runtime` + `View`）
   - CLI 可以直接使用 SDK 核心（`Runtime` + `View`）
   - 兩者共享相同的協議處理邏輯
   - 架構清晰：`Runtime` 管理連接，`View` 管理視圖

### 下一步行動

1. **Phase 1**：重構 CLI 核心為 `Runtime` + `View` 架構，提取到 `SDK/ts/src/core/`
2. **Phase 2**：實作 Code-gen 腳本
3. **Phase 3**：整合 Playground 使用 SDK
4. **Phase 4**：發布 npm 包

## 參考資料

- [Protocol Schema 定義](../protocol/SCHEMA_DEFINITION.md)
- [Transport Protocol](../protocol/TRANSPORT_PROTOCOL.md)
- [舊版 SDK 設計](./DESIGN_CLIENT_SDK.md)（已整合到本文檔）
- [TS SDK 計劃](../ts-sdk-plan.md)（已整合到本文檔）

