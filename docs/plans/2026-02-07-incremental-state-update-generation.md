# Incremental State Update Generation

**Date**: 2026-02-07  
**Status**: Design Complete  
**Branch**: `feat/incremental-state-update-generation`

## Overview

Generate state update patches at mutation time instead of computing diff at sync time. This optimization eliminates the need to traverse the entire state tree during `syncNow()`.

## Problem Statement

### Current Flow
```
Mutation -> @Sync marks isDirty = true
         -> syncNow() called
         -> computeDiff() traverses entire state tree
         -> Compare old vs new snapshot
         -> Generate patches
         -> encode -> send
```

**Performance Issue**: `computeDiff()` has O(n) complexity where n is the size of the state tree, regardless of how many fields actually changed.

### Proposed Flow
```
Mutation -> @Sync setter intercepts
         -> Record patch immediately (with path)
         -> PatchRecorder accumulates patches
         -> syncNow() called
         -> Use accumulated patches directly (skip computeDiff)
         -> encode -> send -> clear PatchRecorder
```

**Benefit**: O(m) complexity where m is the number of mutations, independent of state tree size.

## Design Decisions

| Decision | Choice | Rationale |
|----------|--------|-----------|
| Path injection approach | subscript getter injection | Natural Swift syntax, transparent to users |
| PatchRecorder type | Reference type (class) | Enables tracking across struct copies |
| Thread safety | No lock needed | All mutations happen synchronously within actor |
| API change | Preserve subscript setter | Works via reference type propagation |
| syncNow integration | Direct patch usage | Skip computeDiff entirely |

## Core Components

### 1. PatchRecorder (New)

Location: `Sources/SwiftStateTree/Sync/PatchRecorder.swift`

```swift
/// Protocol for patch accumulation
public protocol PatchRecorder: AnyObject {
    func record(_ patch: StatePatch)
    func takePatches() -> [StatePatch]
    var hasPatches: Bool { get }
}

/// Land-scoped patch recorder (no lock needed - single actor execution)
public final class LandPatchRecorder: PatchRecorder {
    private var patches: [StatePatch] = []
    
    public func record(_ patch: StatePatch) {
        patches.append(patch)
    }
    
    public func takePatches() -> [StatePatch] {
        let result = patches
        patches.removeAll(keepingCapacity: true)
        return result
    }
    
    public var hasPatches: Bool { !patches.isEmpty }
}
```

**Why no lock?**
- Action handlers execute synchronously within `LandKeeper` actor
- Only one handler runs at a time (`withMutableStateSync`)
- No concurrent access possible

### 2. PatchableState Protocol (New)

Location: Generated by `@StateNodeBuilder` macro

```swift
/// Protocol for state types that support incremental patching
public protocol PatchableState {
    var _$parentPath: String { get set }
    var _$patchRecorder: PatchRecorder? { get set }
}
```

### 3. ReactiveDictionary Changes

Location: `Sources/SwiftStateTree/State/ReactiveDictionary.swift`

**subscript getter injects path context:**

```swift
public subscript(key: Key) -> Value? {
    get {
        guard var value = _storage[key] else { return nil }
        
        // Inject path context for patchable values
        if var patchable = value as? PatchableState {
            patchable._$parentPath = "\(_$parentPath)/\(key)"
            patchable._$patchRecorder = _$patchRecorder
            return patchable as? Value
        }
        return value
    }
    set {
        _storage[key] = newValue
        _isDirty = true
        _dirtyKeys.insert(key)
        
        // Record patch for the entire value
        _$patchRecorder?.record(.set(
            path: "\(_$parentPath)/\(key)",
            value: newValue.map { AnyCodable($0) } ?? .null
        ))
        
        onChange?()
    }
}
```

**Why this works for nested mutations:**

When user writes `state.players["A"]?.health = 90`:

1. `subscript get` returns a copy with injected `_$patchRecorder` (reference type)
2. `health = 90` triggers `@Sync` setter on the copy
3. `@Sync` setter records patch to the shared `_$patchRecorder`
4. `subscript set` writes the copy back (Swift COW semantics)

Since `_$patchRecorder` is a reference type, the patch is recorded to the same instance.

### 4. @Sync Property Wrapper Changes

Location: `Sources/SwiftStateTree/Sync/SyncPolicy.swift`

**Setter records patch:**

```swift
// Concept: macro generates this
public var health: Int {
    get { _health.wrappedValue }
    set {
        _health.wrappedValue = newValue
        _$patchRecorder?.record(.set(
            path: "\(_$parentPath)/health",  // Full path
            value: AnyCodable(newValue)
        ))
    }
}
```

### 5. @StateNodeBuilder Macro Changes

Location: `Sources/SwiftStateTreeMacros/StateNodeBuilderMacro.swift`

**Generate additional properties:**

```swift
// For each @StateNodeBuilder struct:
var _$parentPath: String = ""
var _$patchRecorder: PatchRecorder? = nil

// Conform to PatchableState
extension PlayerState: PatchableState {}
```

**Generate path-aware setters for @Sync fields.**

### 6. LandKeeper Integration

Location: `Sources/SwiftStateTree/Runtime/LandKeeper.swift`

**Initialize recorder and inject into state:**

```swift
private let patchRecorder = LandPatchRecorder()

private func initializeState() {
    state._$parentPath = ""
    state._$patchRecorder = patchRecorder
}
```

**syncNow uses accumulated patches:**

```swift
func performSync() async {
    let patches = patchRecorder.takePatches()
    
    if patches.isEmpty { return }
    
    // Direct encode and send, skip computeDiff
    await transport?.send(patches: patches)
}
```

## Data Flow Diagram

```
LandKeeper actor
    |
    v
state (root StateNode)
    |-- _$parentPath = ""
    |-- _$patchRecorder = LandPatchRecorder (shared reference)
    |
    +-- players: ReactiveDictionary
            |-- _$parentPath = "/players"
            |-- _$patchRecorder = same reference
            |
            +-- ["A"]: PlayerState (via subscript get)
                    |-- _$parentPath = "/players/A" (injected)
                    |-- _$patchRecorder = same reference (injected)
                    |
                    +-- health: @Sync
                            |
                            | (mutation: health = 90)
                            v
                        patchRecorder.record(.set("/players/A/health", 90))
```

## Files to Modify

| File | Changes |
|------|---------|
| `Sources/SwiftStateTree/Sync/PatchRecorder.swift` | **New**: PatchRecorder protocol and LandPatchRecorder class |
| `Sources/SwiftStateTree/Sync/PatchableState.swift` | **New**: PatchableState protocol |
| `Sources/SwiftStateTree/State/ReactiveDictionary.swift` | **Modify**: Add path context injection in subscript getter |
| `Sources/SwiftStateTreeMacros/StateNodeBuilderMacro.swift` | **Modify**: Generate `_$parentPath`, `_$patchRecorder`, path-aware setters |
| `Sources/SwiftStateTree/Runtime/LandKeeper.swift` | **Modify**: Initialize recorder, integrate with sync |

## Compatibility

### Reevaluation System
**No changes needed**. Reevaluation is orthogonal to this optimization:
- Reevaluation cares about final state, not patches
- State structure unchanged
- Hash calculation based on full state snapshot

### Existing Code
**Fully backward compatible**:
- Existing `state.players["A"]?.health = 90` syntax works unchanged
- Path injection happens automatically via subscript getter
- No API changes required in user code

## Performance Expectations

| Metric | Current (computeDiff) | After (incremental) |
|--------|----------------------|---------------------|
| Time complexity | O(state_size) | O(mutation_count) |
| Memory | Snapshot + copy | Patches only |
| 100 rooms, 1 mutation each | ~0.08ms | ~0.001ms (estimate) |

## Implementation Plan

1. Add `PatchRecorder.swift` and `PatchableState.swift`
2. Modify `ReactiveDictionary` subscript getter
3. Update `@StateNodeBuilder` macro to generate path context
4. Update `@Sync` setter to record patches (via macro)
5. Integrate with `LandKeeper` sync flow
6. Add unit tests
7. Run E2E tests
8. Benchmark comparison

## Open Questions

1. **StatePatch format**: Should we use JSON Pointer paths or a different format?
2. **Array support**: How to handle `@Sync` arrays (insert/remove/move operations)?
3. **Nested containers**: `ReactiveDictionary` inside `ReactiveDictionary`?

## References

- Branch: `feat/incremental-state-update-generation`
- Related: `Sources/SwiftStateTree/Sync/SyncEngine.swift` (current computeDiff implementation)
- Related: `Examples/GameDemo/Sources/GameContent/States/PlayerState.swift` (typical usage)
